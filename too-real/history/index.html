<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.119.0"><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><title>History - Too Real</title><meta name=author content="robojumper"><meta name=description content="About the Unreal Engine and XCOM 2 modding."><meta name=keywords content="unrealscript,xcom2"><meta property="og:title" content="History"><meta name=twitter:title content="History"><meta property="og:type" content="article"><meta property="og:url" content="https://robojumper.github.io/too-real/history/"><meta property="og:description" content="This article reviews the XCOM 2 implementation of the MVC architecture and investigates some finer details and consequences&mldr;"><meta name=twitter:description content="This article reviews the XCOM 2 implementation of the MVC architecture and investigates some finer details and consequences&mldr;"><meta name=twitter:card content="summary"><meta property="article:published_time" content="2020-11-03T18:00:00+01:00"><meta property="article:modified_time" content="2020-11-03T18:00:00+01:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://robojumper.github.io/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://robojumper.github.io>Too Real</a>
<span class=title-sub>About the Unreal Engine and XCOM 2 modding.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://robojumper.github.io/too-real/history/>History</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-11-03</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;20 minutes</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/unrealscript>unrealscript</a>&nbsp;<a href=/tags/xcom2>xcom2</a>&nbsp;</span></div><div class="post-content markdown-body"><p>Most XCOM 2 mod developers will in some form be familiar with the History and Templates.
And yet, I think it is useful to take a step back and understand the bigger picture around
Firaxis&rsquo; implementation of the Model-View-Controller pattern.</p><p>We will roughly outline the motivation behind and the benefits of such an architecture and
how the History/GameStateObjects, Templates, Contexts, Actions, and Pawns arise from MVC&rsquo;s requirements.
This will hopefully lead to a more intuitive understanding of their roles.</p><p>Finally, we will look at some particular quirks in the XCOM 2 implementation that are useful to know
about in order to write robust code.</p><h2 id=motivation>Motivation</h2><p>An integral part of a video game is showing things on the screen. The Unreal Engine 3 has some incredible
ways to easily get something to draw on screen: Beyond providing a renderer, there&rsquo;s a functional world/camera system,
<code>Actor</code>s we can attach mesh components to, extending to <code>Pawn</code>s providing an animation pipeline and physics.</p><p>As soon as we use the engine to draw a soldier on the screen, we already get a significant part of the gameplay-relevant
functionality for free. We can use the animation pipeline to implement movement. Multiplayer is already handled by the engine.
We give the player a direct presentation and intuitive understanding of the state of the board!</p><p>Everything is going great! The prototype advances rapidly, plenty of bugs crop up, plenty of bugs are fixed. And yet,
some particular bugs seem to happen more frequently. There are reports of the grappling hook causing its users to fall
through the floor under rare circumstances. Multiplayer gameplay performs some actions twice, or not at all. <a href=https://www.reddit.com/r/Xcom/comments/3n4n9k/lw_something_is_seriously_off_with_the_to_hit_for/cvl6a70/ target=_blank>We miss 100% shots.</a></p><p>Worse, we don&rsquo;t really know how to reproduce and fix these problems &ndash; perhaps not even what part of the engine or content
is responsible! Do our maps have holes in them so that soldiers fall through? Is the physics engine buggy, or are the
animations breaking some rules? Is network replication configured correctly? Do our projectiles live long enough?</p><div><div class="interjection info"><p><a href=https://docs.unrealengine.com/udk/Three/ReplicationHome.html target=_blank>Replication</a> is the Unreal Engine 3 solution to multiplayer and networking.
It features a client-server architecture, remote procedure calls, synchronization of variables, lossy data compression, reliable/unreliable data and much more.</p><p>Nobody in the XCOM 2 community knows how it works and the one remnant (UI functions being marked <code>simulated</code>) continues to be cargo-culted.
This is because replication is entirely irrelevant to XCOM 2. I assume it was quite tricky to get right in XCOM EU/EW.</p></div></div><p><p>What these have in common is that systems ostensibly designed for the visual presentation are on the same rank as the actual gameplay:</p><p><img class=img-zoomable src=/img/history/tohuwabohu.png alt="physics and animation on the same rank as gameplay"></p><p>We have a hard time enforcing invariants and separation of concerns. Nothing could possibly tell the game engine that physics should
never move a unit to the adjacent tile when it is idling, or that a unit must successfully land after grappling. Even saving and re-loading
a save can&rsquo;t fix it: Our unit has permanently fallen off the map!</p><p>It would be great if there was an authoritative representation of the tactical board, manipulated only by our own gameplay code. The visual
presentation would then only read from that representation.</p><div><div class="interjection info"><p>This problem is often encountered in frontend applications and user interface. Of course, buttons can&rsquo;t fall out
of the window, but putting our windowing library and GUI toolkit in charge of our business logic can have similarly bad
side effects &ndash; outdated display, greyed-out buttons that should be enabled, impossible input, and a lot of shared responsibilities.</p><p>It&rsquo;s not surprising that the solution employed in XCOM 2 originated from user interface development, sometime in the 70&rsquo;s.</p></div></div><p><h2 id=model-view-controller>Model-View-Controller</h2><p><a href=https://wiki.c2.com/?ModelViewController target=_blank>Model-View-Controller</a> (MVC) aims to solve this issue by:</p><ul><li>Defining a clear boundary between the current state (Model) and the visual presentation (View)</li><li>Requiring a clear set of rules through which the model is manipulated (Controller)</li><li>Ensuring that the View has read-only access to the Model and all modifications to the Model are made through the Controller</li></ul><div><div class="interjection info"><p>Don&rsquo;t attempt to clearly and unambiguously define where exactly the boundary between Model and Controller lies (or what a Controller actually is).
Everyone and their grandmother has their own opinion on that topic.
For the purpose of this post, we&rsquo;ll just roll with one particular interpretation &ndash; mine.<p></p></div></div><p><h3 id=flow-of-information>Flow of information</h3><p>We&rsquo;ll need XCOM 2 terminology here quite a bit, so here&rsquo;s a <em>very</em> condensed explanation of the core tactical gameplay systems:</p><p>The <em>History</em> stores the current state of the battle. The <em>GameRules</em> manage the player turns and build a list of <em>AvailableActions</em>
for all <em>Players</em> and the currently active Player gets to submit one of these actions in form of a <em>Context</em>.
The GameRules evaluate this Context and submit the resulting changes to the History, allowing reaction abilities to trigger,
giving temporary turns to scampering or reacting units.<br>The <em>Visualization</em> independently watches for changes to the History and updates world and pawns.</p><p>Let&rsquo;s visualize this in a diagram where arrows denote flow of information:</p><p><img class=img-zoomable src=/img/history/rules.png alt="visualization of XCOM 2&amp;rsquo;s gameplay systems"></p><p>One thing in particular is worth pointing out right now: No data flows from the View to anywhere else!
Evaluation of ability activation does not rely on visualization having occurred.
Two AI players, who have inherent access to available actions, could play the game entirely without visualization.</p><div><div class="interjection advice"><p>This is a pretty compelling insight into XCOM 2&rsquo;s MVC: Can the AI play without it? Then it&rsquo;s View.<p></p></div></div><p><p>Let&rsquo;s look at some of these parts in more detail!</p><h3 id=history-details>History Details</h3><div><div class="interjection info"><p>Some of this info is also available on the <a href=https://www.reddit.com/r/xcom2mods/wiki/index/game_states target=_blank>Game States</a> page of the /r/xcom2mods wiki.
That particular page contains some useful code samples for directly interacting with the History as it is implemented in XCOM 2.<p></p></div></div><p><h4 id=objects>Objects</h4><p>We need all sorts of information in our model. Information about units, items, their abilities, applied effects, the state of the mission script, objectives.
It makes sense to use UnrealScript&rsquo;s inheritance/polymorphism system for this: We create a <code>class XComGameState_BaseObject extends Object;</code>. Everything we
store as part of the model must be a subclass of <code>XComGameState_BaseObject</code>. This rules out quite a bit of nonsensical interactions: We can&rsquo;t store <code>Actors</code>
in our model (which would be terrible since they&rsquo;re tied to the world), similarly we can&rsquo;t store <code>StaticMeshes</code>. Nice and controlled.</p><div><div class="interjection info"><p>In the interest of keeping things succinct, I will abbreviate the <code>XComGameState_</code> prefix with <code>XCGS_</code>. Instances of <code>XCGS_</code> classes are called &ldquo;state objects&rdquo;.<p></p></div></div><p><p>However, our classes can have arbitrary properties (class variables). Which kinds of these can we save and load? After all, even though we&rsquo;re
limited to adding state objects to the model, we could simply have a <code>var StaticMesh EvilProperty;</code>. What about <code>var XCGS_BaseObject RefToSelf;</code>? Or other weird data
structures that interface closely with the UnrealScript virtual machine?</p><div><div class="interjection info"><p>The process of saving is called <em>serialization</em> because it transforms a complex structure of objects into a serial byte stream.
The opposite procedure, <em>deserialization</em>, follows.<p></p></div></div><p><p>Firaxis made the pragmatic decision to simply not support <code>Object</code> properties when de-/serializing. This avoids cyclicity issues entirely.</p><p>Referring to other state objects objects is a legitimate requirement on the other hand &ndash; without it, we couldn&rsquo;t realize that units
actually own items and abilities. The solution is quite simple: We give every state object a numeric <code>ObjectID</code>. State objects keep
this ID throughout the entire campaign and IDs will not be re-used. The model provides a way to get the state object for a
given ID, so we only need to store the ID when referring to other objects. Firaxis wraps this integer in a single-member struct
called <code>StateObjectReference</code> to neuter all the arithmetic functions useful for integers but entirely pointless for IDs.</p><div><div class="interjection advice"><p>When implementing your own XCOM 2 state objects, bear in mind that only primitive types as well as structs and arrays
are fully supported (except for their Object parts, should they have any). Objects properties are sometimes used for caching
purposes precisely because they don&rsquo;t persist in the save file.</p><p>Delegates (references to functions owned by objects) are special and actually participate in serialization.
Avoid <code>var delegate</code> in state objects unless you know what you are doing and you can ensure that the owning
object is a state object or has a persistent name (i.e. the function is a static method).</p></div></div><p><h4 id=frames>Frames</h4><p>This simple model has one problem: Our visualization, generally responsible for visualizing <em>changes</em>, can only view the state at one point in time.
Worse, if gameplay advances, visualization may miss certain states and instead look at a future state. It is genuinely useful to be able to look at past and future states!</p><div><div class="interjection info"><p>If a unit was on overwatch in the past state and is now no longer on overwatch, we can show an &ldquo;Overwatch removed&rdquo; flyover.<br>If a movement will result in three other units performing overwatch shots, we can prepare a super cinematic camera movement.<p></p></div></div><p><p>It makes sense to store our model as an append-only list of state changes. Let&rsquo;s call it the <em>History</em>.
In order to modify the History, we create a new container (<code>XComGameState</code>) and clone the objects before adding them to
this container and modifying them. When it&rsquo;s done, we submit it to the history.</p><div><div class="interjection advice"><p>We call the <code>XComGameState</code> &ldquo;game state&rdquo;. Note that game states and state objects (<code>XComGameState_BaseObject</code>, <code>XComGameState_Unit</code>) are different.
To make things more confusing, &ldquo;state&rdquo; can refer to game states as well as state objects, for example &ldquo;unit states&rdquo;.</p><p>To disambiguate, game states are sometimes referred to as &ldquo;history frames&rdquo;.</p></div></div><p><p>As an optimization, we only need to clone the objects we are interested in modifying:</p><p><img class=img-zoomable src=/img/history/frames.png alt="visualization of history frames"></p><p>In this example, Unit 2 shot Unit 1 with Item 3 using a free Ability 5. Unit 2 did not change at all, but is still part of the updated state because
it generally makes sense to have the shooter in the game state. Unit 1 lost health and the Overwatch status, Item 3 used ammo. Unit 4 did not participate
in the action at all.</p><p>Even though the object names change, the IDs stay the same. The ObjectID can be used to uniquely identify and track all state objects!</p><div><div class="interjection advice"><p>Hold on to and pass around <code>StateObjectReferences</code>, not <code>XCGS_</code> objects. The more state objects you pass around, the higher the risk of using outdated information.</p><p>On the other hand, simply requesting state objects from the history may result in you looking into the future. You can query game states for state
objects and ask the History for the state objects at arbitrary history indices. This is especially important for visualization, which may end up
<a href=#achievements-and-mission-completion>spoiling results</a> if it doesn&rsquo;t look at state objects from the exact history index as the visualized game state.</p></div></div><p><p>This allows us to answer all kinds of queries and enables as a bonus a History replay feature: We can load a completed tactical
save in replay mode and step through the history, never submitting anything on our own.</p><h3 id=in-context-of>In Context Of</h3><p>Now that we have a rough understanding of the History, it&rsquo;s time to consider the role of the Contexts
(classes with an <code>XComGameStateContext_</code> prefix, here abbreviated as <code>XCGSContext_</code>, sometimes also <code>XCGSC_</code>). In our original diagram,
players and networking submit contexts in order to initiate changes in the history. Why go through this extra hoop?</p><p>It turns out that players can&rsquo;t actually be trusted to play by the rules. Permitting the AI as well as human players to build their
own game states is dangerous: Both AI and UI may operate on outdated information and essentially &ldquo;cheat&rdquo;. It is far safer to present
players with a list of available actions and let them choose one action. The game rules can validate this action easily &ndash; after all,
the game rules handed out the action in the first place.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> The context can then build the game state and the game rules add it to the History.</p><p>The <code>XCGSContext_Ability</code> contains little information, but enough to deterministically build the game state.
In our example, it would contain something akin to &ldquo;Unit 2 uses Ability 5 with Item 3 against Unit 1&rdquo;. Contexts are stored together with their corresponding game state.
This has some great advantages:</p><ul><li>Multiplayer can be realized by sending the contexts only and letting both sides evaluate the context and build the game state independently</li><li>Daily mission leaderboards can be validated by validating the contexts and checking if they create the same game states</li><li>The tactical tutorial (a special history replay) can be realized by simply checking if the to-be-submitted context matches the stored context
(rejecting it otherwise) and just not submitting anything, instead advancing the replay</li></ul><div><div class="interjection advice"><p>All tactical user input must submit a context to achieve changes. It&rsquo;s perfectly fine to submit game states directly in response,
for example from event listeners, as long as the entire event chain can deterministically be triggered from the original context.<p></p></div></div><p><p>In other words, game states contain the answer to &ldquo;what changed?&rdquo;, contexts the answer to &ldquo;why did it change?&rdquo;</p><h4 id=inputs-and-outputs>Inputs and Outputs</h4><p>Unfortunately, one piece is still missing: We don&rsquo;t know about some intermediate results that lead to the changes.
In our example, did the shot graze and deal 2 damage, or did it miss but deal 2 damage due to the stock weapon upgrade?</p><p>Fortunately, since we store the context in the History, we can simply store that information in the context itself.
The <code>XCGSContext_Ability</code> thus has variables part of the <em>input context</em> (who used what against whom?) and part of the <em>output context</em>
(what&rsquo;s the hit result and damage values? which effects applied successfully?)<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><h4 id=interruptions>Interruptions</h4><p>Contexts play another important role because they can produce more than one game state (the context will be cloned for every game state).
For example, every regular ability activation first submits a &ldquo;fake&rdquo; activation (<code>eInterruptionStatus_Interrupt</code>) that triggers relevant events,
but doesn&rsquo;t actually apply any effects. This gives reaction fire abilities a chance to react before the ability performs its effects
(consider Overwatch + Covering Fire).</p><p>If nothing happened in response, this fake game state is removed from the history and the ability is properly activated (<code>eInterruptionStatus_None</code>).
Otherwise, the original game state and all response game states are kept, a copy of the original context is re-validated (the unit may have died from reaction fire),
and this copy is properly submitted (<code>eInterruptionStatus_Resume</code>).<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>Further, movement abilities trigger an interruption game state for every single step. Only the steps actually causing a reaction and the final step are kept.
If no response actions are performed along the path, the movement is a single jump from source to destination.</p><div><div class="interjection advice"><p>If you have an event listener for successful ability activations, you may want to filter interruption steps with
<code>if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) return ELR_NoInterrupt;</code>, lest your code runs twice for every ability activation.<p></p></div></div><p><p>With all this in mind, it&rsquo;s perhaps best to review the <a href=#flow-of-information>architecture diagram</a> and see if it makes more sense.</p><h3 id=templated>Templated</h3><p>Templates sort of transcend the entire system. They contain view data, game rules input, and instructions for game rules.
Dissecting the <code>X2AbilityTemplate</code>, we have:</p><ul><li>View<ul><li>Ability icons</li><li>Targeting methods (allowing the user to select an action)</li><li><code>BuildVisualizationFn</code> (prepares the visualization for activated ability)</li></ul></li><li>Game rules input<ul><li>Conditions</li><li>Costs</li><li>Target styles (building the list of actions)</li></ul></li><li>Game rules instructions<ul><li>Effects</li><li>Costs</li><li><code>BuildNewGameStateFn</code> (builds the game state for activated ability)</li></ul></li></ul><div><div class="interjection info"><p>This is, of course, not a violation of MVC. We factored all of these aspects into the original architecture diagram. No data flows from View to anywhere else.<p></p></div></div><p><h3 id=archived>Archived</h3><p>Our approach to the History has the problem of unlimited growth. With every mission, our save file contains more and more objects,
and more and more versions of the same object. This would spiral out of control quickly. Firaxis employs a number of mitigations.</p><p><strong>TacticalTransient</strong> objects are never retained after the end of a tactical mission. This includes ability states, effect states, and players.
You can make objects TacticalTransient by setting the class variable <code>bTacticalTransient</code> in <code>defaultproperties</code>:</p><pre><code class=language-java>defaultproperties
{
	bTacticalTransient=true
}
</code></pre><p>Items and Units are not TacticalTransient, so even dead enemies and their items from tactical missions are retained. Additionally, we still store
more and more history frames and contexts even though we don&rsquo;t need to look back into what happened on turn 3 of Gatecrasher.</p><p><strong>StartStates</strong> are game states that act as a barrier. When we go from strategy to tactical, we create a start state and copy everything relevant into that start state.
This includes units in the squad and excludes units not in the squad. When we iterate over all units in the History from now on, we only get the units actually on
the battlefield.</p><div><div class="interjection info"><p>Start states are the only game states that are allowed to be modified after being submitted as long as they&rsquo;re the latest game state in the history.
They are usually combined with a History lock that prevents other game states from being submitted.</p><p>The strategy->tactical transition is a relatively complex series of loading maps, instantiating state objects for map actors, spawning units, and
setting up the mission script, all while the start state is on top of the History. At some point the History is unlocked and everything proceeds as normal.</p></div></div><p><p>At the same time, submitting a start state causes all previous game states to be squashed into a single game state with an &ldquo;archive&rdquo; context.
At the end of the battle, this <strong>archive state</strong> is retrieved, its objects are copied into the new strategy start state, and the objects are updated with
their tactical versions in case they participated in the tactical session.</p><div><div class="interjection advice"><p>The tactical History is <strong>missing objects</strong>. If you use <code>OnLoadedSavedGame</code> to make modifications with the installation of your mod, your changes may find some
strategy objects missing. Prefer a combination of <code>OnLoadedSavedGameToStrategy</code> and <code>OnPostMission</code>.</p><p>If you write code that relies on certain objects being brought along in a strategy->tactical transition, you can add them in <code>OnPreMission</code>.</p></div></div><p><p>Ideally this would mean that at some point, all enemy units and their weapons would be left behind.
Unfortunately, there are multi-part missions like the Shen&rsquo;s Last Gift tower mission. This tactical->tactical transfer would mean strategy objects would
be left behind, so we can&rsquo;t leave objects behind and the archive state continues to accumulate some garbage.</p><div><div class="interjection info"><p>There is an <a href=https://github.com/X2CommunityCore/X2WOTCCommunityHighlander/pull/179 target=_blank>attempt</a> to fix it in the Highlander. Everybody is scared to approve it
because it may delete important units from mods that re-use base-game templates.<p></p></div></div><p><h2 id=violations>Violations</h2><p>There are a number of ways you can violate MVC:</p><ul><li>Directly submit game states from user input in tactical</li><li>Modify state objects part of already submitted game states</li><li>Submit contexts or game states from visualization</li><li>Make changes dependent on the current state of the visualization</li><li>Cause observable side effects from code building a game state</li><li>Attempt to build a game state while there is a game state currently being built</li></ul><div><div class="interjection advice"><p>Sometimes it&rsquo;s not obvious whether a game state is &ldquo;in flight&rdquo;. Event listeners registered with <code>ELD_Immediate</code> for events triggered
in game state code can usually rely on <code>NewGameState</code> being in flight and mutable, but event listeners registered with <code>ELD_OnStateSubmitted</code>
cannot. The <a href=https://www.reddit.com/r/xcom2mods/wiki/index/events#wiki_deferral target=_blank>Events/Deferral</a> section of the /r/xcom2mods wiki
elaborates on this point further.</p><p>Moreover, a game state might sometimes be in flight due to multi-threading/latent submissions in WotC. This deserves a separate blog post,
just don&rsquo;t submit a context while <code>`XCOMGAME.GameRuleset.IsDoingLatentSubmission()</code> returns <code>true</code> for now.</p></div></div><p><p>For the rest of the blog post, we&rsquo;ll look at some particular violations that happen in base-game code.</p><h3 id=unconscious-units>Unconscious Units</h3><p>Units knocked out will have a knockback effect applied to them that may move them to a different tile. Physics rarely cooperate, so
once the ragdoll settles, it submits a game state that corrects the unit&rsquo;s position.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> This ensures the unit is where players would expect
it to be, but can cause race conditions with AI code.</p><div><div class="interjection info"><p>I think this violation is not justified, especially in face of the practical issues it causes with AI.<p></p></div></div><p><h3 id=hit-rolls>Hit Rolls</h3><p>A perhaps surprising fact is that rolling for an ability hit happens entirely before a game state is built,
despite the RNG seed definitely being part of the Model. Abilities actually support not submitting a game state upon failing to roll a hit.
No abilities make use of this, but it seems like it was intended to work for the concealment system, where enemies would have a chance
to notice player units.</p><p>This is a small violation as long as it only happens in reaction abilities / responses to events.</p><p>More seriously, some effects directly write to state objects in the history as part of determining ability hit results.
Consider this simplified function from <code>X2Effect_Parry</code>:</p><pre><code class=language-java>function bool ChangeHitResultForTarget(XCGS_Unit TargetUnit, out EAbilityHitResult NewHitResult)
{
	if (TargetUnit.Parry &gt; 0 &amp;&amp; TargetUnit.IsAbleToAct())
	{
		NewHitResult = eHit_Parry;
		TargetUnit.Parry -= 1;
		return true;
	}
	return false;
}
</code></pre><p>This is about as serious in that it only happens in response abilities, but it does write directly to the History. Bad idea.</p><div><div class="interjection advice"><p>There are two kinds of random functions: The built-in <code>Rand()</code> function and the Firaxis <code>`SYNC_RAND()</code> macro.
Use <code>Rand()</code> for visualization and <code>`SYNC_RAND()</code> for game state code &ndash; the former does not affect the saved RNG seed, the latter does.<p></p></div></div><p><h3 id=achievements-and-mission-completion>Achievements and Mission Completion</h3><p>Steam/platform achievements are triggered when the game state is built. This essentially spoils results because the achievement pops up as soon
as the player hits the &ldquo;confirm&rdquo; button. This could easily be fixed by making achievement unlocks part of the visualization.</p><div><div class="interjection advice"><p>Every context has a <code>PostBuildVisualizationFn</code> delegate array that can be added to from game state code in order to add additional visualization
even if you don&rsquo;t control the variables in the context.<p></p></div></div><p><p>Similarly, upon confirming the action that will complete the mission, all UI is hidden.</p><div><div class="interjection info"><p>These are not MVC violations because no data flows from view, but more visualization bugs.<p></p></div></div><p><h3 id=map>Map</h3><p>At a glance, the map seems like a giant MVC violation. Actors are responsible for building the tile grid, pathing and visibility.
Further, even though a lot of map actors are destructible, almost none of them have corresponding state objects.</p><p>This is handled by native code, but upon further inspection, the world data seems to be able to speculatively apply environmental damage
and update visibility and pathing internally without visualization having occurred.</p><p>Moreover, even though destructible map actors generally have no state objects, saving and loading retains environment damage. This is because
the events that lead to map destruction are part of the history and simply re-played upon loading a saved game.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup><p></p><div><div class="interjection info"><p>If we recall our AI insight (&ldquo;does the AI need this?&rdquo;), then it&rsquo;s resoundingly clear that the map and its meshes are part of the state too.
It&rsquo;s iffy and okay to feel a bit uneasy about, but it works <em>OK-ish</em>.</p><p>Sometimes map actors like to self-destruct right after confirming an action, but this could easily be just a visualization bug, not an MVC violation.</p></div></div><p><h3 id=cursor-targeting>Cursor targeting</h3><p>Pixel hunting is the XCOM player&rsquo;s favorite obsession. Unsurprisingly, grenades and heavy weapons allow freely targeting the ability on
the tactical map, so the game rules don&rsquo;t actually provide a list of all available actions and leave it to the players, which mostly
results in the AI hitting seemingly (and sometimes actually) impossible shots &ndash; players create the target for cursor-targeted abilities
on the fly and there&rsquo;s no validation.</p><p>On top of that, some targeting methods actually use info from the unit pawn to build the heavy weapon path, particularly around
visibility checking and ray tracing.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p><div><div class="interjection info"><p>There&rsquo;s no good solution for the first problem. Even tile-snapping would result in a huge possible target list.
The second problem is a plain old MVC violation that should have been addressed by using the unit state tile location and not the actor location.<p></p></div></div><p><h3 id=strategy>Strategy</h3><p>This article was focused on tactical. The strategy gameplay is <strong>a lot</strong> less principled about this, knows no concept of available actions and often submits
<code>ChangeContainers</code> (a dummy context where the game-state is pre-built already) directly. Narrative moments randomly interfere and cause race conditions
with UI screens that have pending game states (like customization). Strategy keeps the History for state management, but doesn&rsquo;t concern itself with MVC at all.</p><h2 id=closing-words>Closing Words</h2><p>I hope this article was insightful and helped you understand XCOM 2&rsquo;s tactical architecture. Moreover, I hope you will keep the presented concepts in mind
and use them to confidently write and review code that interacts with the History, Contexts, and tactical MVC.</p><p><em>I would like to thank Xymanek for reviewing a draft of this blog post and providing valuable feedback.</em></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>See <code>X2TacticalGameRuleset:GetGameRulesCache_Unit</code>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>See <code>XComGameStateContext_Ability:InputContext/OutputContext</code> and corresponding definitions in <code>X2TacticalGameRulesetDataStructures</code>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>See <code>X2GameRuleset:SubmitGameStateContext_Internal</code>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>See <code>XComUnitPawn:SyncCorpse</code>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>See <code>XComGameState_EnvironmentDamage</code>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>See <code>X2TargetingMethod_RocketLauncher:Update</code>, particularly <code>FiringUnit.Location</code>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY</a>.</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments</span>
<script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","robojumper/robojumper.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/projects/>Projects</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/robojumper target=_blank><span>GitHub</span></a></li><li><a href=https://twitter.com/robojumper_ target=_blank><span>Twitter</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/unrealscript/>unrealscript</a></span>
<span><a href=/tags/xcom2/>xcom2</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#model-view-controller>Model-View-Controller</a><ul><li><a href=#flow-of-information>Flow of information</a></li><li><a href=#history-details>History Details</a><ul><li><a href=#objects>Objects</a></li><li><a href=#frames>Frames</a></li></ul></li><li><a href=#in-context-of>In Context Of</a><ul><li><a href=#inputs-and-outputs>Inputs and Outputs</a></li><li><a href=#interruptions>Interruptions</a></li></ul></li><li><a href=#templated>Templated</a></li><li><a href=#archived>Archived</a></li></ul></li><li><a href=#violations>Violations</a><ul><li><a href=#unconscious-units>Unconscious Units</a></li><li><a href=#hit-rolls>Hit Rolls</a></li><li><a href=#achievements-and-mission-completion>Achievements and Mission Completion</a></li><li><a href=#map>Map</a></li><li><a href=#cursor-targeting>Cursor targeting</a></li><li><a href=#strategy>Strategy</a></li></ul></li><li><a href=#closing-words>Closing Words</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/projects/>Projects</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/robojumper target=_blank><span>GitHub</span></a></li><li><a href=https://twitter.com/robojumper_ target=_blank><span>Twitter</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/unrealscript/>unrealscript</a></span>
<span><a href=/tags/xcom2/>xcom2</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#model-view-controller>Model-View-Controller</a><ul><li><a href=#flow-of-information>Flow of information</a></li><li><a href=#history-details>History Details</a><ul><li><a href=#objects>Objects</a></li><li><a href=#frames>Frames</a></li></ul></li><li><a href=#in-context-of>In Context Of</a><ul><li><a href=#inputs-and-outputs>Inputs and Outputs</a></li><li><a href=#interruptions>Interruptions</a></li></ul></li><li><a href=#templated>Templated</a></li><li><a href=#archived>Archived</a></li></ul></li><li><a href=#violations>Violations</a><ul><li><a href=#unconscious-units>Unconscious Units</a></li><li><a href=#hit-rolls>Hit Rolls</a></li><li><a href=#achievements-and-mission-completion>Achievements and Mission Completion</a></li><li><a href=#map>Map</a></li><li><a href=#cursor-targeting>Cursor targeting</a></li><li><a href=#strategy>Strategy</a></li></ul></li><li><a href=#closing-words>Closing Words</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2023
<a href=https://robojumper.github.io>robojumper</a>
| <a href=https://github.com/robojumper/robojumper.github.io>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>