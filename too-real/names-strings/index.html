<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.119.0"><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><title>Names and Strings - Too Real</title><meta name=author content="robojumper"><meta name=description content="About the Unreal Engine and XCOM 2 modding."><meta name=keywords content="unrealscript"><meta property="og:title" content="Names and Strings"><meta name=twitter:title content="Names and Strings"><meta property="og:type" content="article"><meta property="og:url" content="https://robojumper.github.io/too-real/names-strings/"><meta property="og:description" content="This article introduces the blog post series, and looks into detail at how strings and names are implemented under the hood in UnrealScript&mldr;"><meta name=twitter:description content="This article introduces the blog post series, and looks into detail at how strings and names are implemented under the hood in UnrealScript&mldr;"><meta name=twitter:card content="summary"><meta property="article:published_time" content="2020-10-27T18:17:51+01:00"><meta property="article:modified_time" content="2020-10-27T18:17:51+01:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://robojumper.github.io/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://robojumper.github.io>Too Real</a>
<span class=title-sub>About the Unreal Engine and XCOM 2 modding.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://robojumper.github.io/too-real/names-strings/>Names and Strings</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-10-27</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;13 minutes</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/unrealscript>unrealscript</a>&nbsp;</span></div><div class="post-content markdown-body"><div><div class="interjection info"><p>Welcome to <em>Too Unreal</em>, a blog post series about some lesser-known aspects of the XCOM 2 engine and the Unreal Engine 3 that it is based on, particularly about UnrealScript.</p><p>This series is not going to be a modding tutorial, but is instead meant to provide some additional details and insights into how things work under the hood.
At the same time, I&rsquo;m not keeping it too dry &ndash; this series will contain case studies, personal anecdotes, and advice that will be useful to keep in mind if you end
up working on more sophisticated UnrealScript code.</p><p>Other topics I plan on covering are data layout, out parameters and subtyping, function dispatch, multitasking. I&rsquo;m also open to suggestions; this blog uses <a href=https://utteranc.es target=_blank>utterances</a> for comments.</p></div></div><p><p>In this blog post, we&rsquo;re going to explore how strings and names in UnrealScript work.</p><h2 id=textbook-definitions>Textbook definitions</h2><p>The official UnrealScript documentation ends up being quite terse:</p><blockquote><p><strong>string</strong><br>A string of characters.<br><strong>name</strong><br>The name of an item in Unreal (such as the name of a function, state, class, etc). Names are stored as an index into the global name table. Names correspond to simple strings of up to 64 characters. Names are not like strings in that they are immutable once created.</p><footer><strong>Epic Games</strong>
<cite><a href=https://docs.unrealengine.com/udk/Three/UnrealScriptVariables.html#Variable%20Types title=https://docs.unrealengine.com/udk/Three/UnrealScriptVariables.html#Variable%20Types rel="noopener noreferrer">Unreal Script Variables</a></cite></footer></blockquote><p>This intuitively matches what we expect from those data types:</p><pre><code class=language-java>local name MyName, MyName2;
local string MyString, MyString2;

MyString = &quot;Hi&quot;;
MyString2 = MyString;
MyString $= &quot;, ÜC!&quot;; // mutate string
`log(MyString); // ScriptLog: Hi, ÃœC!

MyName = 'Adv';
MyName2 = MyName;
MyName $= 'M1'; //❌ Error, Left type is incompatible with '$='
MyName = 'Other'; // re-assignment isn't mutation
</code></pre><p>Let&rsquo;s delve into a bit more detail about how these data types might be implemented under the hood.</p><h2 id=strings>Strings</h2><p>UnrealScript hides a lot of the complexity here but the C++ side needs to allocate memory for every variable.
For a 32-bit integer (<code>int</code>), this size is known at compile-time (4 bytes), but a string can have arbitrary length (and grow/shrink at runtime).
As a result, the <code>string</code> stores its data as a separate allocation:</p><p><img class=img-zoomable src=/img/names-strings/string.png alt="string allocation visualization"></p><p>With this, the data needed to store the string has a fixed size: A pointer to the actual data and the string length.
These strings are terminated with a <code>NUL</code> character, as is common in the C world.</p><p>Let&rsquo;s see what happens when we append the <code>", ÜC!"</code> to the existing string:</p><p><img class=img-zoomable src=/img/names-strings/string-realloc.png alt="string re-allocation visualization"></p><p>The string re-allocates: It allocates a new, longer block of memory, copies the old data into it, appends the new string, and throws away (&ldquo;frees&rdquo;) the old data.
That&rsquo;s why we can freely mutate a string. But this means that creating a copy of the string requires a new allocation and duplicates the string data: If both strings pointed to the same data, changing one string would change the other too &ndash; or worse, we would throw away data that the other string is still referring to!</p><h3 id=encoding-woes>Encoding Woes</h3><p>Unfortunately, the string isn&rsquo;t what we expected: Instead of printing as &ldquo;Hi, ÜC!&rdquo;, it output &ldquo;Hi, ÃœC!&rdquo;. This is a consequence of the Unreal Engine 3 only supporting the ASCII and UTF-16 encodings when the original source file was saved in the UTF-8 encoding.</p><div><div class="interjection info"><p>Encodings are the way we represent codepoints (&ldquo;characters&rdquo;) of the character set as bytes. The most common character set is <a href=https://home.unicode.org/ target=_blank>Unicode</a>, and UTF-16 is one possible encoding. UTF-16 uses two bytes per character; UTF-8 uses 1-4 bytes per character.</p><p>ASCII is a mostly alphanumeric subset of Unicode that only requires one byte per character, and all ASCII strings encode to the same bytes as the equivalent UTF-8 string.</p></div></div><p><p>The Unreal Engine recognizes UTF-16 files by a Byte-Order-Mark (BOM), two unprintable bytes at the beginning of a file that indicate an UTF-16 encoding.
An UTF-8 file has no BOM, so the compiler (being part of the engine) believes that the file is ASCII only and interprets the two bytes needed to represent the &ldquo;Ü&rdquo; codepoint as two ASCII characters &ldquo;Ã&rdquo; and &ldquo;œ&rdquo;.</p><div><div class="interjection advice"><p>Restrict yourself to ASCII-only code. Localize strings, and save localization files with an UTF-16 BOM encoding.</p><p>Some software, particularly source code management tools like <code>git</code>, will interpret UTF-16 files as binary files and not text. It can be useful
to store localization files in UTF-8 and convert to UTF-16 as part of the build process, as done by Long War of the Chosen in its <a href=https://github.com/long-war-2/lwotc/blob/aac5d46a3a7cae57241c8573c7fd0a167d1ffcb4/.scripts/build.ps1#L406-L411 target=_blank>custom build script</a>.</p></div></div><p><h2 id=names>Names</h2><p>Even though the official documentation makes it seem like names are reserved for built-in things, we can use names for anything! Case in point, the XCOM 2 engine uses names for Templates and configuration array entries like loot, loadouts or encounters.</p><p>Names have some unique properties not mentioned in the documentation:</p><ul><li>The empty name, <code>''</code>, compares equal to the name <code>'None'</code>.</li><li>Name comparison is case-insensitive: <code>'MyName' == 'mYnAmE'</code>.</li></ul><p>Let&rsquo;s look a bit into how this global name table works.</p><h3 id=the-name-table>The Name Table</h3><p>The documentation says that names are stored as an index into the name table. This means that instead of owning the string data, a <code>name</code> is basically just a fancy <code>int</code>. We have a number of requirements for the implementation:</p><ol><li>Names should reliably and efficiently be comparable: Two names should compare equal if and only if their indices are equal. This means that comparing two names is as efficient as comparing two <code>int</code>s.</li><li>Names should be efficiently created: No matter how many thousand names we already have, creating a name from a string should always take the same, low amount of time.</li><li>Names should efficiently be serialized: While storing names as integers is great when the game is running, we should save them as strings when we write them to a file so that we don&rsquo;t have to rely on the numbers being the same when the game boots up the next time (spoiler: they wouldn&rsquo;t be).</li></ol><p>There are two pieces needed to make this work: The first is a name array; an ever-growing array containing every single name created, without duplicates. Whenever we want to create a name not already present in the name table, we can simply generate a new index by looking at the array length; and we can look up the string behind a name by indexing into this array. This piece already solves (1.) and (3.)!</p><p>When creating a name, we have to check if a that name already exists &ndash; otherwise, we could end up with the same name twice, and the same name would have a different index. Unfortunately, we&rsquo;d have to iterate over the whole name array to find a name comparing equal. The Unreal Engine 3 solves this by employing a <a href=https://en.wikipedia.org/wiki/Hash_table target=_blank>hash set</a>.</p><p>This hash set is a fixed-size array with a comparatively low number of entries (say 32768), and we use a hash function to find the correct entry (&ldquo;container&rdquo;, &ldquo;bucket&rdquo;) for a given string. When we create a name from a string, we find the correct bucket, and check if the name is already there. If so, we have an existing name and re-use the index. If not, we add the new name to the name array and insert it also into this bucket.</p><div><div class="interjection info"><p>The <a href=https://en.wikipedia.org/wiki/Pigeonhole_principle target=_blank>pigeonhole principle</a> states that &ldquo;if <em>n</em> items are put into <em>m</em> containers, with <em>n > m</em>, then at least one container must contain more than one item&rdquo;.</p><p>Applied to our hash set, there will be <em>collisions</em>: Different names will have the same hash, otherwise we could never have more than 32768 names. This means that we store multiple names in the same bucket, and still have to check multiple existing names to see if any of them match (although I&rsquo;m unsure about the exact implementation, we&rsquo;re going to assume that the Unreal Engine 3 uses linked list chaining).</p><p>However, instead of checking <em>N</em> existing names, we only check <em>N</em> / 32768 names. Much better!</p></div></div><p><p>In addition to the special name <code>'None'</code>, we&rsquo;ll consider the three names from our code snippet: <code>'Adv'</code>, <code>'M1'</code>, and <code>'Other'</code>. Let&rsquo;s see what our data structures look like:</p><p><img class=img-zoomable src=/img/names-strings/names.png alt="name table visualization"></p><p>In our example, the names were inserted in the afore-mentioned order. <code>'None'</code> has the hash 0, <code>'Adv'</code> the hash 2, and <code>'M1'</code> and <code>'Other'</code> both share the hash 5. When we created the name <code>Other</code>, <code>M1</code> was already in that bucket, <code>M1</code> does not compare equal to <code>Other</code>, so we linked <code>'Other'</code> before <code>'M1'</code> and placed <code>'Other'</code> into that bucket.</p><div><div class="interjection info"><p>Names are an Unreal Engine 3 implementation of <a href=https://en.wikipedia.org/wiki/String_interning target=_blank>string interning</a>: For every string, we only store data once, and can then cheaply create and compare several instances of the string.<p></p></div></div><p><h3 id=memory-leaks>Memory leaks</h3><p>This implementation never reclaims unused name data. Once we create a name, it will reside in the name table (and thus memory) until the game is closed! We can easily test this with the following code:</p><pre><code class=language-java>local string BaseString;
local name TempName;
local int i;

BaseString = &quot;MySomewhatLongerBaseStringForHigherMemoryUsage&quot;;

`log(&quot;Starting...&quot;);
for (i = 0; i &lt; 35000000; ++i)
{
    TempName = name(BaseString $ &quot;_&quot; $ i);
    if (i % 500000 == 0)
    {
      `log(i); // progress indicator and timer
    }
}
`log(&quot;Done!&quot;);
</code></pre><div><div class="interjection info"><p>Let&rsquo;s estimate the memory usage:</p><p><code>"MySomewhatLongerBaseStringForHigherMemoryUsage"</code> is 46 characters long. We add an underscore and 8 digits, and the NUL character (total 112 bytes with our above knowledge of strings). We require 4 bytes for the index, 8 bytes (on a 64-bit system) for the <code>Next</code> pointer, and another 8 bytes for the pointer entry in the names array. We expect memory usage to rise by about 112B * 35e6 = 4.62GB.</p></div></div><p><p>The measurements were performed on an Intel Core i5-3470 @ 3.20GHz, launched through a console command in TQL (to minimize interference from the game).</p><ul><li>Time: 39.86s</li><li>Memory usage increase: 0MB</li></ul><p>Wait, what? Our memory usage had no significant change!</p><div><div class="interjection info"><p>Let&rsquo;s revisit what our assumption would practically mean: When we <code>new</code> an object, say <code>new class'XComLWTuple'</code>, the engine assigns a unique name to that object.
We start with <code>XComLWTuple_0</code>, then <code>XComLWTuple_1</code> etc. Even though our <code>XComLWTuple</code>s are garbage collected, we never re-use existing numbers: Our tuple object names are monotonically increasing.</p><p>If names worked that way, we would reliably end up polluting our name table; and even though UnrealScript has a garbage collector, we would end up leaking memory!</p></div></div><p><h4 id=the-number-optimization>The Number Optimization</h4><p>Simply put, a <code>_Number</code> suffix is stripped before interning. Our names don&rsquo;t actually consist of one number, but two numbers instead. The first number is an index into the name array, the second number is the numeric suffix.</p><p>Let <code>'XComLWTuple'</code> be our sixth name. Then the name <code>'XComLWTuple'</code> would be represented as <code>6|0</code> (0 for no suffix). <code>'XComLWTuple_0'</code> would be represented as <code>6|1</code>, <code>'XComLWTuple_1'</code> as <code>6|2</code>, <code>'XComLWTuple_345'</code> as <code>6|346</code>.</p><p>Our example code managed to trigger this optimization: Our names are <code>'MySomewhatLongerBaseStringForHigherMemoryUsage_0'</code>, <code>'MySomewhatLongerBaseStringForHigherMemoryUsage_1'</code>, and so on. This means that the game interns the <code>MySomewhatLongerBaseStringForHigherMemoryUsage</code> once and all our synthetic names re-use that index, just with a different number part. Testing two names for equality is thus a matter of comparing the two integers of the two names.</p><h4 id=lets-break-it-for-real>Let&rsquo;s Break It For Real</h4><p>With this knowledge, we can try to circumvent this optimization:</p><pre><code class=language-java>local string BaseString;
local name TempName;
local int i;

BaseString = &quot;MySomewhatLongerBaseStringForHigherMemoryUsage&quot;;

`log(&quot;Starting...&quot;);
for (i = 0; i &lt; 35000000; ++i)
{
    //TempName = name(BaseString $ &quot;_&quot; $ i);
    TempName = name(i $ &quot;_&quot; $ BaseString);
    if (i % 500000 == 0)
    {
      `log(i); // progress indicator and timer
    }
}
`log(&quot;Done!&quot;);
</code></pre><ul><li>Time: 848.09s</li><li>Memory usage increase: 3.11GB<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ul><p>With this snippet, we leaked more than 3 Gigabytes of memory. This memory is permanently leaked and will not be reclaimed until we close the game.</p><p>There is another problem: With every name we synthesize, our hash set becomes less efficient. We never resize the 32768 entries large hash set, so we have more and more collisions, and we have to check longer and longer lists of interned names whenever we create another name. We can plot the elapsed duration over the number of names created:</p><p><img class=img-zoomable src=/img/names-strings/perf.png alt="visualization of elapsed time for synthesizing 35M names"></p><div><div class="interjection info"><p>The trained programmer recognizes this as an <code>O(n^2)</code> algorithm; An algorithm whose runtime is quadratic to some input size. The more names we add, the longer it takes to add another name. Algorithms like this are best avoided.<p></p></div></div><p><p>Of course, 35 million names are a bit extreme, but not <em>that</em> extreme &ndash; crash dumps indicate that a normally running game has about three million interned strings.</p><p>But this explains why we cannot concatenate names, and have to go through strings: A name type that conveniently allows concatenation and mutation would make it extremely easy to accidentally pollute the name table and inhibit performance until we close the game.</p><div><div class="interjection advice"><p>Names are usually only created at game startup (including template creation code). Names should only contain alphanumeric characters and underscores.</p><p>Avoid synthesizing arbitrary names after that, only convert from <code>string -> name</code> when necessary. <code>_Number</code> suffixes, however, are free.</p></div></div><p><h3 id=capitalization>Capitalization</h3><p>We&rsquo;ve explored the <code>string -> name</code> conversion in detail, but there&rsquo;s one pitfall when going from <code>name -> string</code>: We can&rsquo;t rely on any particular capitalization:</p><pre><code class=language-java>local int MYcUstOMnAmE;
`log('MyCustomName'); // ScriptLog: MYcUstOMnAmE
</code></pre><p>The Unreal Engine uses <code>name</code>s to represent the name of (among other things) local variables, so when the compiler encounters the <code>'MyCustomName'</code> string, the name has already been interned as <code>"MYcUstOMnAmE"</code>. The <code>name -> string</code> conversion uses the first representation of the name it encountered, and that&rsquo;s <code>MYcUstOMnAmE</code>.</p><h4 id=flash-ui>Flash UI</h4><p>You can actually cause breakage with this if even if you personally never interact with any code that relies on capitalization! Here&rsquo;s a super cursed hack you can try in the Highlander:</p><pre><code class=language-java>// in CHDLCInfoTopologicalOrderNode.uc
var bool LeftPanel;
</code></pre><p>And suddenly we broke our loadout menu:</p><p><img class=img-zoomable src=/img/names-strings/ui-hack.jpg alt="broken loadout menu"></p><p>This is because <code>UIArmory_Loadout</code> has this code:</p><pre><code class=language-java>EquippedListContainer = Spawn(class'UIPanel', self);
EquippedListContainer.bAnimateOnInit = false;
EquippedListContainer.InitPanel('leftPanel');
</code></pre><p>This creates a <code>UIPanel</code> that links up with a panel of the name <code>leftPanel</code> on the Flash side &ndash; except Flash is case-sensitive even though Firaxis&rsquo; API takes names! The compiler parses our <code>LeftPanel</code> first, and when it encounters the <code>leftPanel</code>, <code>LeftPanel</code> is the interned representation.</p><div><div class="interjection advice"><p>Never rely on the <code>name -> string</code> conversion to make any sense at all. Never display names to the user, only use them for debugging purposes.</p><p>If you interact with existing Flash UI directly, ensure you don&rsquo;t have name conflicts with differing capitalization. In your own mods, you can&rsquo;t break base game UI because you compile after base-game packages, but especially when working on the Highlander or when developing sophisticated UI, this is a huge footgun.</p></div></div><p><h4 id=warning-ini-file-contains-an-incorrect-case-for>Warning, INI file contains an incorrect case for</h4><p>There is a particularly annoying compiler warning that sporadically appears for some config variables:</p><pre><code class=language-java>//⚠️ Warning, INI file contains an incorrect case for (CoverType) should be (coverType)
var config ECoverType coverType;
</code></pre><p>This warning references an <code>INI</code> file even when we haven&rsquo;t modified any config files at all! This warning should better be described with</p><blockquote><p>Warning, config variable coverType actually named CoverType</p></blockquote><p>because the compiler had, at some point (perhaps even in <code>XComGame</code>) seen the name <code>CoverType</code>, so this variable is actually called <code>CoverType</code>.
In fact, the compiler seemingly records this mismatch because config files are actually case-sensitive, and the runtime is clever enough to
not use an arbitrary string representation of the variable name when loading from config.</p><p>To &ldquo;fix&rdquo; it, either follow the <em>opposite</em> of the advice and call it <code>CoverType</code>, or choose an entirely different name.</p><h2 id=closing-words>Closing Words</h2><p>That&rsquo;s it for the first entry in the series! If there is anything you&rsquo;d like to have clarified regarding this topic, feel free to reach out in the comments!</p><p>Similarly, I&rsquo;m open to suggestions for topics to cover next.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This memory usage is lower than expected. This is because names representable in ASCII are stored as ASCII to save space. The same happens when saving strings to packages or save files.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY</a>.</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments</span>
<script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","robojumper/robojumper.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/projects/>Projects</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/robojumper target=_blank><span>GitHub</span></a></li><li><a href=https://twitter.com/robojumper_ target=_blank><span>Twitter</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/unrealscript/>unrealscript</a></span>
<span><a href=/tags/xcom2/>xcom2</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#textbook-definitions>Textbook definitions</a></li><li><a href=#strings>Strings</a><ul><li><a href=#encoding-woes>Encoding Woes</a></li></ul></li><li><a href=#names>Names</a><ul><li><a href=#the-name-table>The Name Table</a></li><li><a href=#memory-leaks>Memory leaks</a><ul><li><a href=#the-number-optimization>The Number Optimization</a></li><li><a href=#lets-break-it-for-real>Let&rsquo;s Break It For Real</a></li></ul></li><li><a href=#capitalization>Capitalization</a><ul><li><a href=#flash-ui>Flash UI</a></li><li><a href=#warning-ini-file-contains-an-incorrect-case-for>Warning, INI file contains an incorrect case for</a></li></ul></li></ul></li><li><a href=#closing-words>Closing Words</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/projects/>Projects</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/robojumper target=_blank><span>GitHub</span></a></li><li><a href=https://twitter.com/robojumper_ target=_blank><span>Twitter</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/unrealscript/>unrealscript</a></span>
<span><a href=/tags/xcom2/>xcom2</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#textbook-definitions>Textbook definitions</a></li><li><a href=#strings>Strings</a><ul><li><a href=#encoding-woes>Encoding Woes</a></li></ul></li><li><a href=#names>Names</a><ul><li><a href=#the-name-table>The Name Table</a></li><li><a href=#memory-leaks>Memory leaks</a><ul><li><a href=#the-number-optimization>The Number Optimization</a></li><li><a href=#lets-break-it-for-real>Let&rsquo;s Break It For Real</a></li></ul></li><li><a href=#capitalization>Capitalization</a><ul><li><a href=#flash-ui>Flash UI</a></li><li><a href=#warning-ini-file-contains-an-incorrect-case-for>Warning, INI file contains an incorrect case for</a></li></ul></li></ul></li><li><a href=#closing-words>Closing Words</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2023
<a href=https://robojumper.github.io>robojumper</a>
| <a href=https://github.com/robojumper/robojumper.github.io>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>