[{"content":"Last blog post was about Properties, so a logical continuation is looking at functions next. In particular, we\u0026rsquo;re going to address how functions are called and what happens before the function body is executed.\nWe\u0026rsquo;re first going to look at what the generic sequence of events for a function call looks like, and then investigate every step in more detail. The general sequence of events will go something like:\nFind function Allocate stack frame (see Functions in last week\u0026rsquo;s blog post) Default-initialize locals, copy non-out function arguments to stack frame, link out arguments Execute function body Finding the function UnrealScript, by default, allows subclasses to override functions. That means that in advance, we don\u0026rsquo;t know which particular function will be called when we have an object \u0026ndash; it\u0026rsquo;s entirely possible we\u0026rsquo;re looking at a subclass and the function we\u0026rsquo;re looking to call might be overridden. Last week\u0026rsquo;s blog post revealed that there is a FindFunctionChecked C++ function to find a function by name \u0026ndash; let\u0026rsquo;s imagine what it might look like:\nUFunction* UObject::FindFunctionChecked(FName FuncName) { UFunction *Result = NULL; UClass *CheckClass = GetClass(); while (CheckClass != NULL) { Result = CheckClass-\u0026gt;Functions.Find(FuncName); if (Result != NULL) { return Result; } CheckClass = CheckClass-\u0026gt;GetSuperClass(); } appErrorf(\u0026quot;Failed to find function %s in %s\u0026quot;, FuncName.ToString(), this-\u0026gt;ToString()); } Whenever we call a function, we have to look up this function in the current class. If not found, we have to check the superclass, and repeat until we found it.\nOf course, it\u0026rsquo;s possible the function doesn\u0026rsquo;t exist \u0026ndash; for example when it\u0026rsquo;s a Highlander-provided function but the Highlander is not enabled:\nCritical: appError called: Assertion failed: appErrorf [File:G:\\BuildAgent\\work\\9a884cb2af69f6ff\\main\\XCOM2\\Development\\Src\\Core\\Src\\UnObj.cpp] [Line: 2456] Failed to find function SubscribeToOnInput in UIScreenStack XPACK_Shell_Intro.TheWorld:PersistentLevel.XComShellPresentationLayer_0.UIScreenStack_0 This virtual dispatch (named after C++\u0026rsquo;s virtual functions) has a cost: We have to perform at least one hash map lookup every time we want to call a function \u0026ndash; and more lookups the further our subclass is away from the lowest function definition. This is particularly expensive for functions in Object.uc since it\u0026rsquo;s the root of the inheritance chain and functions there are the furthest away they could possibly be.\nFinal functions There is one trick to mitigate this cost: The final keyword, which prohibits subclasses from overriding the function. The compiler exploits this by generating a non-virtual function call \u0026ndash; it embeds the function reference directly as an object and lets the dynamic linker resolve this call once, at package load time. We can measure this effect (i5-3470 @ 3.20GHz):\nexec function BenchFunctionCall(optional int num = 100000000) { local int i; `log(\u0026quot;Bench No-Op Start\u0026quot;); for (i = 0; i \u0026lt; num; i++) { } `log(\u0026quot;Bench No-Op End\u0026quot;); `log(\u0026quot;Bench Func Start\u0026quot;); for (i = 0; i \u0026lt; num; i++) { SubFunction(); } `log(\u0026quot;Bench Func End\u0026quot;); `log(\u0026quot;Bench Final Func Start\u0026quot;); for (i = 0; i \u0026lt; num; i++) { SubFunction2(); } `log(\u0026quot;Bench Final Func End\u0026quot;); } function SubFunction() { } final function SubFunction2() { } Virtual dispatch: 30ns / call Non-virtual dispatch: 20.2ns / call A private function is always final. Since private functions are entirely invisible to outside classes and subclasses, they also don\u0026rsquo;t need virtual dispatch.\nMarking functions final reduces the overhead from calling functions. The benefit increases the more likely it is for instances to be further down the inheritance chain.\nBasically all functions in Object.uc are final.\nDelegates Delegates always link to a concrete function and object, so there\u0026rsquo;s no name lookup involved when calling through a delegate. Still, it\u0026rsquo;s more expensive than calling a final function directly because we need to retrieve the delegate property data first, which requires more pointer accesses.\nThe Stack Frame Once we find our function, we need to allocate space for the stack frame (unless we\u0026rsquo;re calling a native function, where the C++ compiler generated whatever code). We can try to purposefully blow up the stack frame size:\nfinal function SubFunctionSmall() { local int Prop1; } final function SubFunctionMedium() { local int Prop1, Prop2, Prop3, Prop4, Prop5, Prop6, Prop7, Prop8; } final function SubFunctionLarge() { local int Prop1, Prop2, Prop3, Prop4, Prop5, Prop6, Prop7, Prop8, Prop9, Prop10; local int Prop11, Prop12, Prop13, Prop14, Prop15, Prop16, Prop17, Prop18, Prop19, Prop20; local int Prop21, Prop22, Prop23, Prop24, Prop25, Prop26, Prop27, Prop28, Prop29, Prop30; local int Prop31, Prop32; } Nevermind my \u0026ldquo;unreferenced local variable\u0026rdquo; warnings.\nWith a baseline of no locals, the overhead of locals can be determined:\nBaseline (no locals): 20.8ns / call Small (1 int local): 57.0ns / call Medium (8 int locals): 58.9ns / call Large (32 int locals): 62.4ns / call Turns out that without any locals, the UnrealScript virtual machine needs to allocate no stack frame at all, so it\u0026rsquo;s reasonably cheap. Once we have any local variables, we need to allocate space for the stack frame, which makes this much more expensive \u0026ndash; mostly regardless of the number and size of locals.\nArguments Initializing locals is comparatively cheap, since the default value for all property data is represented as the all-zeros bit pattern and the stack frame just needs to be zeroed. Arguments, on the other hand, need to be copied over, which is more costly, especially since some arguments require an unbounded amount of memory to be copied:\nfinal function int FindMax(array\u0026lt;int\u0026gt; arr) { // ... } For this function, the entire array data needs to be copied too, since FindMax requested a copy of the full array. For a 100-element array, this function call takes 128.1ns \u0026ndash; and will take longer the longer the array is.\nWe can improve this by using the out parameter mode: out means that we reference the original array storage location without copying all data:\nfinal function int FindMax(out array\u0026lt;int\u0026gt; arr) { // ... } Again, for a 100-element array, this takes 44.6ns, but this will be independent of the array size.\nThis has the small disadvantage that our function could now modify the array and have it affect the calling code. We can mark this parameter as const out to take away the mutability. const out is always meant to be a performance optimization, since the const takes away all the functionality added by out.\nout properties have a higher overhead on access \u0026ndash; don\u0026rsquo;t indiscriminately mark every argument as out. Arrays and structs usually make sense to pass by out.\n958 functions in the base game make use of const out.\nOut Parameter Soundness One thing you might have come across with out parameters is that dynamic array elements can\u0026rsquo;t be out parameters. Consider the following code snippet:\nvar array\u0026lt;int\u0026gt; TheArray; function Ok() { self.TheArray.AddItem(1); // ❌ Error, Call to 'Evil', parameter 1: Not allowed to pass a dynamic array element as the value for an out parameter self.Evil(TheArray[0]); } function Evil(out int SomeInt) { self.TheArray.AddItem(3); `log(SomeInt); // ⚡ } If we remember anything from last week\u0026rsquo;s blog post, it\u0026rsquo;s that arrays store their elements on a separate allocation. By adding an element while holding a pointer to another element, the array would re-allocate and we could access freed memory in the line commented with ⚡:\nAny safe language must reject this; C# supports out/ref parameters too and rejects this. Both UnrealScript and C# never allow dynamic array elements as out/ref parameters.\nRust is a safe language with a sophisticated borrow checker that would reject this particular code but doesn\u0026rsquo;t disallow dynamic array elements as references when it can prove that the array can\u0026rsquo;t be modified in the function.\nIn unsafe languages like C and C++, retaining access to de-allocated memory cannot be prevented by the compiler and actual access causes use-after-free errors, generally a security- and safety-relevant class of bugs.\nAssorted Modifiers Static A static function behaves as if it doesn\u0026rsquo;t have an associated instance. Access to self is disallowed, and the function can be called without having an instance. Yet, there is an owning object (the Class Default Object/CDO), and dispatch is still virtual (since you could explicitly be calling the function on a sub-class that doesn\u0026rsquo;t override the function yet but does at some later point).\nSingular Whenever a singular function is called, the VM sets a \u0026ldquo;we\u0026rsquo;re in a singular function\u0026rdquo; flag and clears it when that function returns. When the flag is set, calls to singular functions are skipped.\nThis is used in the base game to prevent runaway recursion from physics events. Please don\u0026rsquo;t use it in any algorithms; it\u0026rsquo;s global state and an awful hack.\nSimulated The simulated modifier is only relevant for Replication, the Unreal Engine 3 solution to networking and multiplayer. I don\u0026rsquo;t think anyone in the XCOM 2 community understands this system well enough to explain what simulated does. In XCOM 2, we mark all UI functions as simulated as a sort of cargo cult.\nAlternatively \u0026hellip; don\u0026rsquo;t call any functions at all. It would be great if the UnrealScript compiler supported merging small private functions into calling functions (called Inlining), but it doesn\u0026rsquo;t. If you have some code that gets slowed down significantly by leaf function calls, consider manually inlining the function body.\nThis is something I experimented with in an UnrealScript implementation of QuickSort. Calling the comparison function/delegate (which necessarily has arguments and a hence a stack frame) can be unreasonably expensive.\nClosing words I believe that at this point, I have covered the topics I set out to cover when I started this blog post series. Expect future entries to be published sporadically at best and to cover smaller bits and interesting facts about UnrealScript instead of grand topics.\nThanks for reading!\n","date":"2020-12-08","permalink":"https://robojumper.github.io/too-real/dispatch/","tags":["unrealscript"],"title":"Function Dispatch"},{"content":"This is a topic that comes up once every while, but has wide-reaching implications for many parts of the UnrealScript language and mod development, particularly when working on the Highlander. We\u0026rsquo;re going to delve into the internals of property storage and, more practically, clear up why you can\u0026rsquo;t pass booleans as out parameters, and why attempts to add variables to native classes have been unceremoniously shot down.\nWhat even are properties Intuitively, properties is the term UnrealScript uses for variables, though this definition leaves room for interpretation as to what a variable exactly is.\nConsider the following code snippet:\nclass MyClass extends Object; var int GlobalCounters[2]; // int property of arity 2 in class struct SomeStruct { var bool Cached; // bool property in struct var bool PrevValue; // bool property in struct var array\u0026lt;int\u0026gt; ChangeCounters; // int array property in struct }; var SomeStruct State; // struct property in class delegate OnConditionChange(bool NewValue); // delegate property in class // Argument properties vvvvvvvvvvvvvvv--vvvvvvvv function bool CheckCondition(Actor ChkObject, int Fact, out string Dbg) { // ^^^^ bool property return out property ^^^^^^^^^^^^^^ local float Tmp; // float property in function // complicated logic omitted return Tmp \u0026gt; 0.0f; } I\u0026rsquo;ve marked all properties with comments. The code snippet demonstrates that there are different kinds of properties, corresponding to the UnrealScript types:\nPrimitive types like Byte/Enum, Int, Bool, Float, Name Composite types like Struct, Map Owning types like Array, String Reference types like Object, Interface, Delegate We can make a reverse observation: All properties have an owner! This code snippet exhibits the three kinds of property owners UnrealScript has:\nClasses Structs Functions Finally, the astute reader has noticed the var int GlobalCounters[2] \u0026ndash; all properties have an arbitrary, but fixed at compile-time arity \u0026ndash; properties can store a fixed number of values (by default 1).\nWhere\u0026rsquo;s the data? Naïve implementation In a very simplistic implementation, the properties would own the data themselves. There would be a Property class:\nclass Property extends Field abstract; var name PropertyName; var int Arity; All different property kinds would be implemented in a fairly similar manner1:\nclass FloatProperty extends Property; var float Value[Arity]; Note that these examples use a syntax similar to UnrealScript. The actual implementation would, of course, be written in C++.\nOur property owner would then look something like this:\nclass Class extends Object; var Class SuperClass; var array\u0026lt;Property\u0026gt; Properties; Instantiating a class is then simply a matter of cloning the Properties array of the class and all its super classes and their contents.\nLet\u0026rsquo;s visualize how this naïve implementation stores the class property data:\nThere are several problems with this approach:\nIt wastes space! Even without an actual instance, our properties store some value even though it\u0026rsquo;s not useful. Instances store copies of metadata like name, arity even though it stays constant for all instances. It wastes performance! Every property is a new allocated object, so getting to the property data requires following at least two pointers, which is bad for CPU cache efficiency: The Properties array must allocate its contents somewhere because the number of properties isn\u0026rsquo;t known, and even different for different classes. Getting to the array contents is the first pointer indirection. Every Properties entry itself is a reference to an object allocated somewhere, so we have to follow another pointer. Instantiating a class requires copying all metadata. It\u0026rsquo;s inconvenient to efficiently work with on the C++ (native) side! C++ has a fairly predictable layout algorithm and places all member data (class/struct variables) into one contiguous memory region, with one allocation for the entire class or struct. It would be great to lay out all data in the exact same way so that we get C++ interoperability for free. Borrowing from C++ This last point offers a very practical solution: We store the property data in one big chunk of bytes, and instead of having our properties store the data themselves, they instead store where in that data chunk the property data lies:\nclass Property extends Field abstract; var name PropertyName; var int Arity; var int Offset; This is a massive improvement: Even if we instantiate our class hundreds of times, all instances share the same property metadata and only the pink-colored data is unique to instances. Every property has an offset that matches the position of the data in the data block.\nThe array data isn\u0026rsquo;t stored in that same block because we don\u0026rsquo;t know in advance how many elements will be stored, and accordingly the array allocates storage separately.\nIf we were to mark our class and struct as native, the compiler would automatically generate the following header file:2\nstruct FSomeStruct { BITFIELD Cached:1; BITFIELD PrevValue:1; TArray\u0026lt;INT\u0026gt; ChangeCounters; }; class UMyClass : public UObject { public: //## BEGIN PROPS MyClass INT GlobalCounters[2]; struct FSomeStruct State; FScriptDelegate __OnConditionChange__Delegate; //## END PROPS MyClass } For UnrealScript, the exact layout doesn\u0026rsquo;t really matter: When a script package is loaded, the UnrealScript code within references the properties by name, and the dynamic linker will translate those names into offsets once, at load time.\nFor C++ however, this data layout is important: As long as the UnrealScript compiler lays out the property data the exact same way as the C++ compiler used for the game, the data pointer ObjectInstance-\u0026gt;Data pointing to a seemingly random chunk of bytes can be re-interpreted as a pointer to a UMyClass *; a pointer to a C++ class.\n\u0026ldquo;The way data is laid out in memory\u0026rdquo; is part of the ABI, the Application Binary Interface. Even though C++ doesn\u0026rsquo;t guarantee any particular layout, the UnrealScript compiler just needs to match what the particular C++ compiler does.\nMost notably, C++ places alignment requirements on some data: A 64-bit pointer needs to be placed at addresses that are a multiple of 8 bytes, so we have some padding to round up from 12 to 16 bytes between the booleans and the ChangeCounters array.\nThe C++ side has no dynamic linker for properties. Changes to native class or struct properties cause a change in the header file and require a full re-compile of the C++ side.\nIf the C++ side is not recompiled, native will access variables at the wrong offsets and will read and write garbage data.\nDo not modify the properties of native classes or structs. Modders have no way to re-compile any C++ code, so ABI-incompatible changes cause unfixable problems. The compiler and game will sometimes even error out at startup time for some changes.\nNative-only types The C++ header has a TArray\u0026lt;INT\u0026gt; corresponding to an array\u0026lt;int\u0026gt;. These two types have the exact same data layout, so both UnrealScript code and C++ code can use the same array with the same data without any conversion costs. This array type is built into the engine combined with appropriate UnrealScript op-codes to access this array.\nBut there are also types that cannot be accessed from UnrealScript, but are important to have in a class for native code. Consider the UnitValues map:3\nvar private native Map_Mirror UnitValues{TMap\u0026lt;FName, FUnitValue\u0026gt;}; This corresponds to the following C++ declaration:\nclass UXComGameState_Unit : public UXComGameState_BaseObject, public IX2GameRulesetVisibilityInterface, public IX2VisualizedInterface, public IDamageable { public: //## BEGIN PROPS XComGameState_Unit // ... TMap\u0026lt;FName, FUnitValue\u0026gt; UnitValues; C++ has no problems accessing this map, but there are no ways to access the map from UnrealScript. What is Map_Mirror even defined as?\nstruct pointer { var native const int Dummy; }; struct BitArray_Mirror { var native const pointer IndirectData; var native const int InlineData[4]; var native const int NumBits; var native const int MaxBits; }; struct SparseArray_Mirror { var native const array\u0026lt;int\u0026gt; Elements; var native const BitArray_Mirror AllocationFlags; var native const int FirstFreeIndex; var native const int NumFreeIndices; }; struct Set_Mirror { var native const SparseArray_Mirror Elements; var native const int InlineHash; var native const pointer Hash; var native const int HashSize; }; struct Map_Mirror { var native const Set_Mirror Pairs; }; Wow! That\u0026rsquo;s a lot! All of this is necessary to exactly mirror the C++ data layout. All properties are const to prevent UnrealScript from mucking with native data structures, while C++ code can freely work with this map. Notably, these structs are kept in sync manually: The {TMap\u0026lt;FName, FUnitValue\u0026gt;} suffix in the declaration tells the UnrealScript compiler to simply generate a declaration with an entirely different native type instead of using Map_Mirror.\nBooleans If we review the Borrowing from C++ section, there\u0026rsquo;s a few weird things about booleans:\nSeveral booleans have the same offset Booleans have an extra PackIndex C++ implements them with BITFIELD \u0026lt;name\u0026gt;:1 It turns out that UnrealScript stores up to 32 consecutive booleans as individual bits of a 32-bit integer. In order to address a boolean, we not only need the address of that integer, but also the individual bit index.\nAs a consequence, the UnrealScript virtual machine has separate op-codes for boolean property assignment and other property assignment.\nThere\u0026rsquo;s also an op-code for out property assignment, but not one for out boolean property assignment. out bool is thus unsupported.\nFunctions We\u0026rsquo;ve mentioned before how not only classes and structs, but also functions can own properties. Let\u0026rsquo;s re-visit our example function:\nfunction bool CheckCondition(Actor ChkObject, int Fact, out string Dbg) { local float Tmp; // complicated logic omitted return Tmp \u0026gt; 0.0f; } It turns out that functions do something extremely similar to classes. All function arguments and local properties are allocated in one chunk:\nBoth function arguments and local properties are part of the stack frame \u0026ndash; a data block allocated for all these properties upon calling the function. The out parameter is not present in this data block because out parameters live somewhere else \u0026ndash; the entire point of out parameters is to skip the part where the data needs to be copied to the stack frame and back; and the code directly writes to the borrowed storage location.\nThere\u0026rsquo;s even a hidden return property that the function writes to upon returning; the UnrealScript VM retrieves the return value from there.\nThere is a difference between class properties and function argument properties: Class properties are accessed by name, but when we call a function we pass the function arguments by index. If we switched around arguments in package A, package B that calls this function needs to not only be re-compiled, but also re-written since the argument order and types no longer match.\nOne exception are optional parameters; they may be added to the end of the arguments list without breaking dependent UnrealScript code.\nAs always, native code makes things more complicated. For example, the following event\nstatic event ModifyTacticalTransferStartState(XComGameState TransferStartState) { } is turned into the following call stub:\nstruct X2DownloadableContentInfo_eventModifyTacticalTransferStartState_Parms { class UXComGameState* TransferStartState; }; class UX2DownloadableContentInfo : public UObject { public: // ... void eventModifyTacticalTransferStartState(class UXComGameState* TransferStartState) { X2DownloadableContentInfo_eventModifyTacticalTransferStartState_Parms Parms(EC_EventParm); Parms.TransferStartState=TransferStartState; ProcessEvent(FindFunctionChecked(XCOMGAME_ModifyTacticalTransferStartState),\u0026amp;Parms); } } Similarly, we can\u0026rsquo;t modify the arguments list of existing events: This C++ code allocates the data block for all function arguments on the stack as a X2DownloadableContentInfo_eventModifyTacticalTransferStartState_Parms struct and copies the arguments into it (similar to what a data block for class properties looks like), so the C++ side assumes a fixed size and offsets.\nStrictly speaking, this doesn\u0026rsquo;t only apply to events. Events are more convenient to call from C++, but nothing prevents native code from calling regular functions the same way. Usually it\u0026rsquo;s safe to assume only events are called from C++.\nOne thing that works in our favor here is that functions are found by name (with FindFunctionChecked) when calling, so we can easily add functions to native classes without breaking the ABI.\nClosing Words There\u0026rsquo;s a closely related topic we\u0026rsquo;ve approached in the last part of this post: Function dispatch. In a separate blog post, we\u0026rsquo;re going to look at how functions are called, out parameters are implemented, and how subtyping/variance interacts with them.\nIgnore the [Arity] part for now; it\u0026rsquo;s unlikely to work in any programming language but actually implementing it is out of scope for the demonstration of a naïve proposal\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAuto-generated header files can be found in Development/Src/*/Inc/*.h\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee XComGameState_Unit.UnitValues\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-12-01","permalink":"https://robojumper.github.io/too-real/properties/","tags":["unrealscript"],"title":"Properties"},{"content":"\u0026ldquo;How do I fix my load order?\u0026rdquo; ask many many XCOM 2 mod users, but there are several kinds of load orders, some of which are unreliable and can\u0026rsquo;t even be changed. We\u0026rsquo;re going to look at the different kinds of load orders, clear up some misconceptions, and see how they affect mod dependencies.\nConfig files The /r/xcom2mods wiki has a page Configuration Files and Variables that contains a more practical introduction to config files, troubleshooting advice and some mod interoperability tricks.\nThis is the most important and most impactful kind of load order. As a quick reminder, config files consist of key-value pairs (KVP) that are conceptually inserted into a multi-map (a key-values map where multiple values can correspond to one key).\nWe have access to some syntax translating to commands for the config map:\nKey=Value: Set the entry Key to Value +Key=Value: Add to entry Key the value Value if not present .Key=Value: Add to entry Key the value Value -Key=Value: Remove from entry Key the value Value if present !Key=(): Clear entry Key This is a strictly serial process. Config files and the lines within are processed in order.\nFor base-game config files and files in the user directory (Documents/My Games/XCOM 2 (WotC)/XComGame/Config), Key=Value entries are interpreted as +Key=Value.\nOnly after all config files have been loaded, config variables are imbued with the values from the config map. How it precisely works depends on the kind of variable.\nPrimitive types use the value inserted last Static (fixed-size) arrays look for VarName[0], VarName[1], \u0026hellip; keys and use the respective value inserted last Arrays are special Array indexing +VarName=... and VarName[_]=... have no interaction at all. Several +VarName=... KVPs produce a key with multiple values, VarName[_]=... KVPs with different indices produce different keys.\nArrays look for the VarName key and insert all entries in order into the array. Only if VarName isn\u0026rsquo;t found, they look for VarName[0], VarName[1], \u0026hellip; keys, using the last inserted value, until one isn\u0026rsquo;t found.\n+CArray=\u0026quot;PlusZero\u0026quot; +CArray=\u0026quot;PlusOne\u0026quot; CArray[1]=\u0026quot;AtOne\u0026quot; ; results in CArray = [\u0026quot;PlusZero\u0026quot;, \u0026quot;PlusOne\u0026quot;] in UnrealScript CArray[0]=\u0026quot;AtZero\u0026quot; CArray[1]=\u0026quot;AtOne\u0026quot; CArray[3]=\u0026quot;AtThree\u0026quot; ; results in CArray = [\u0026quot;AtZero\u0026quot;, \u0026quot;AtOne\u0026quot;] in UnrealScript h4ilst0rm pointed out to me that for arrays in structs, skipped entries are filled with the default value, so if this array were part of a struct, (CArray[0]=\u0026quot;AtZero\u0026quot;, CArray[1]=\u0026quot;AtOne\u0026quot;, CArray[3]=\u0026quot;AtThree\u0026quot;) would result in [\u0026quot;AtZero\u0026quot;, \u0026quot;AtOne\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;AtThree\u0026quot;].\nTextual identity It\u0026rsquo;s also a strictly textual process \u0026ndash; the config parser has no knowledge of the actual types of the variables:\n+IArray=1 +IArray=01 +IArray=1 ; results in IArray = [1, 1] in UnrealScript +SArray=(i=5) +SArray=(i=6) -SArray=(i=5) -SArray=(i = 6) ; results in SArray = [A { i = 6 }] in UnrealScript Minor formatting differences such as white-space, indentation, capitalization and leading zeros are relevant for the removal of entries.\nLoad order Since single-value types use the last inserted entry, the config file processed last usually wins. But at the same time, if a certain approach relies on removing previous array entries, only the first processed mod has any chance to textually match an original entry. Config load order is important, and here\u0026rsquo;s the guaranteed parts of the order:\nUser directory (Documents/My Games/XCOM 2 (WotC)/XComGame/Config) DLC directories (XCOM 2/XCom2-WarOfTheChosen/XComGame/DLC/*/Config) Mod directories (XCOM 2/XCom2-WarOfTheChosen/XComGame/Mods/*/Config and workshop/content/268500/*/Config) It is obvious that base-game config is loaded first. DLCs happen to be loaded after that, and then it\u0026rsquo;s mod directories. The game knows of the mod directories through a config array ModRootDirs in XComEngine.ini, and it turns out that the order there determines whether workshop mods or local mods are loaded first! Within these orders, mods are loaded alphabetically by their folder name.1\nIn the workshop directory, these folder names correspond to the strictly monotonically increasing UGC (Steam user-generated content) IDs. This does not mean mods uploaded later load later \u0026ndash; in fact, mods with the IDs 20, 100 and 101 will be loaded in the order 100, 101, 20 due to how the lexicographic comparison of folder names works.\nOf course, the simple act of moving a workshop folder to the local mods folder (for local development or in order to prevent updates) changes everything.\nA common misconception is that the order of the ActiveMods in XComModOptions.ini determines config load order. For the longest time, the Alternative Mod Launcher had offered a \u0026ldquo;load order\u0026rdquo; column that affected only the ActiveMods array.\nThis is wrong. Config load order is rarely guaranteed and should not be relied on by mod authors.\nWorkarounds This causes a bunch of issues in practice. Some base-game config arrays use VarName[_]=... syntax, so mods cannot use the +VarName syntax to add to the array \u0026ndash; and explicit indices would be incompatible with other mods. One example of this are ability availability codes \u0026ndash; a config and a localized array that map a tactical condition error code to a user-displayed string.\nIt can be useful to modify these arrays from code: Declare copies of the arrays in your own class, fill them in from your private config files, then copy them over at runtime (code simplified from Rising Tides: The Program):\nvar config array\u0026lt;name\u0026gt; NewAbilityAvailabilityCodes; var localized array\u0026lt;String\u0026gt; NewAbilityAvailabilityStrings; static event OnPostTemplatesCreated() { local X2AbilityTemplateManager\tAbilityTemplateManager; local int\tidx; AbilityTemplateManager = X2AbilityTemplateManager(class'Engine'.static.FindClassDefaultObject(\u0026quot;XComGame.X2AbilityTemplateManager\u0026quot;)); // If there are more codes than strings, this inserts blank strings to bring them to equal before adding our new codes // If there are more strings than codes, this cuts off the excess before adding our new codes AbilityTemplateManager.AbilityAvailabilityStrings.Length = AbilityTemplateManager.AbilityAvailabilityCodes.Length; // Append new codes and strings to the arrays for (idx = 0; idx \u0026lt; default.NewAbilityAvailabilityCodes.Length; idx++) { AbilityTemplateManager.AbilityAvailabilityCodes.AddItem(default.NewAbilityAvailabilityCodes[idx]); AbilityTemplateManager.AbilityAvailabilityStrings.AddItem(default.NewAbilityAvailabilityStrings[idx]); } } This avoids compatibility issues and even fixes errors arising from mods doing the config entries wrong. I do something similar for WotC: More Photobooth Options, and custom code can help the many cases where mod compatibility is a concern but the config syntax is not expressive enough (perhaps even custom Rulers).\nWhen the code becomes too complex, the Highlander sometimes provides features for mod code to easily modify config tables in a compatible way. For example, the Highlander has a \u0026ldquo;Loot Table API\u0026rdquo; that allows mods to modify the enemy tactical loot drops without stomping on other mods\u0026rsquo; changes.\nScript packages This config load order produces another load order because config files are the way mods tell the game to load script packages. Every mod with a script package has at least one entry in its NonNativePackages:\n[Engine.ScriptPackages] +NonNativePackages=LW_Tuple +NonNativePackages=DetailedSoldierListWOTC Not only affects this which packages are loaded, but also the order in which they are loaded.\nDependencies Package B depends on package A if A needs to be compiled and loaded before package B. Contrary to content packages, script packages do not cause their dependencies to be loaded automatically. We can visualize, as an example, the dependency graph for Long War of the Chosen @ dfbe52c because it probably has the most complex dependency graph:\nThis dependency graph is a directed acyclic graph (DAG): The edges are directed (an edge from A to B means A depends on B, but not the other way around) and the nodes are acyclic (there aren\u0026rsquo;t any cycles).\nCycles are impossible because script packages are compiled and loaded one after another, but now we need to find out a good order for our packages to be compiled and loaded in.\nIf the packages are listed in the wrong order for the compiler, the compiler will throw errors. If the packages are loaded in the wrong order at run-time, the game will have incredible bugs arising from certain classes and functions missing from the loaded UnrealScript bytecode. The requirement for our NonNativePackages order is that if there is an edge from A -\u0026gt; B, then B must come before A in the order. Such an order is called a topological ordering, always exists for a DAG, and one such ordering can be found \u0026ndash; unsurprisingly \u0026ndash; in LWotC\u0026rsquo;s XComEngine.ini\n[Engine.ScriptPackages] +NonNativePackages=LW_Tuple +NonNativePackages=XModBase_Interfaces +NonNativePackages=XModBase_Core_2_0_2 +NonNativePackages=LW_XModBase +NonNativePackages=WallClimbOverride +NonNativePackages=LWUtilities +NonNativePackages=ModConfigMenuAPI +NonNativePackages=LW_XCGS_ModOptions +NonNativePackages=LW_XCGS_ToolboxOptions +NonNativePackages=LW_SMGPack_Integrated +NonNativePackages=LW_LaserPack_Integrated +NonNativePackages=NewPromotionScreenByDefault_Integrated +NonNativePackages=PI_Integrated +NonNativePackages=LW_PerkPack_Integrated +NonNativePackages=LW_OfficerPack_Integrated +NonNativePackages=LW_AlienPack_Integrated +NonNativePackages=LW_Toolbox_Integrated +NonNativePackages=LW_WeaponsAndArmor +NonNativePackages=LW_FactionBalance +NonNativePackages=LW_Overhaul Meta-mods We call mods that modify other mods \u0026ldquo;meta-mods\u0026rdquo;, and in this example, we\u0026rsquo;re looking to make a mod that requires some code from LW_WeaponsAndArmor. It\u0026rsquo;s tempting to make our NonNativePackages look like this:\n[Engine.ScriptPackages] +NonNativePackages=LW_WeaponsAndArmor +NonNativePackages=MyMetaMod Unfortunately, this has a fatal problem: Config load order is not guaranteed. If our meta-mod configs are loaded before LWotC\u0026rsquo;s, then LW_WeaponsAndArmor is loaded before all of its dependencies. The dependency graph looks like this:\nThe pink highlighted packages are transitive dependencies of MyMetaMod: MyMetaMod\u0026rsquo;s direct dependencies, and dependencies of its dependencies and so on. All transitive dependencies need to be listed in NonNativePackages to defend against bad load order:\n[Engine.ScriptPackages] +NonNativePackages=LW_Tuple +NonNativePackages=XModBase_Interfaces +NonNativePackages=XModBase_Core_2_0_2 +NonNativePackages=LW_XModBase +NonNativePackages=LWUtilities +NonNativePackages=LW_XCGS_ModOptions +NonNativePackages=LW_SMGPack_Integrated +NonNativePackages=LW_PerkPack_Integrated +NonNativePackages=LW_WeaponsAndArmor +NonNativePackages=MyMetaMod This is the minimal packages list \u0026ndash; we could also just wholesale copy the entire LWotC NonNativePackages list.\nIf LWotC receives an update that changes the order in its package list, MyMetaMod needs to be updated too \u0026ndash; otherwise the outdated MyMetaMod can potentially mess up the package load order of LWotC.\nRun order Package load order is crucial for mods to even work in the first place, but it also controls the order in which DLC hooks like OnPostTemplatesCreated and entry points like CreateTemplates are called. It can be useful for mods to do their template modifications in a specific order, for example RPG Overhaul needs to run before Primary Secondaries for those mods to pick up changes made to secondary weapons before creating primary versions.\nThe Highlander implements a system it calls Run order that allows mods to specify that their DLC hooks are ran before or after other mods.2 The Highlander sorts the DLCInfo classes at startup so that all DLC hooks are automatically affected:\n[XCOM2RPGOverhaul CHDLCRunOrder] RunPriorityGroup=RUN_LAST +RunBefore=\u0026quot;PrimarySecondaries\u0026quot; +RunBefore=\u0026quot;WOTC_LW2SecondaryWeapons\u0026quot; Closing words I hope this cleared some things up. If there\u0026rsquo;s one takeaway here, it\u0026rsquo;s that config load order is not guaranteed and config syntax is not expressive enough to solve many problems \u0026ndash; and UnrealScript code can help. For some particular problems, the Highlander can jump in and provide additional helpers \u0026ndash; don\u0026rsquo;t hesitate to ask if the Highlander can help with one of them.\nAccording to Raymond Chen, on NTFS at least it\u0026rsquo;s \u0026ldquo;B-tree order, which if you cover one eye and promise not to focus too closely looks approximately alphabetical for US-English\u0026rdquo;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis feature doesn\u0026rsquo;t have great documentation right now. I will add a link here once the Highlander has it documented.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-11-17","permalink":"https://robojumper.github.io/too-real/load-order/","tags":["unrealscript","xcom2"],"title":"Load Order"},{"content":"It\u0026rsquo;s common wisdom that \u0026ldquo;the Unreal Engine 3 is single-threaded\u0026rdquo;. Despite that, there are some less and some more surprising sources of parallelism that can happen in UnrealScript, particularly XCOM 2.\nIn this post, we\u0026rsquo;ll first look at how one frame in the Unreal Engine 3 works (in particular, actor and component ticking) and the kind of parallelism happening there, and then move over to some more sources of concurrency and parallelism.\nWhat happens in a frame Before we can talk about what happens in parallel, we need to establish what actually happens in a single frame. On a very high level, most games have a game loop that looks something like Input-\u0026gt;Gameplay-\u0026gt;Render:\nThe Unreal Engine 3 documentation offers bullet points about its internal workings,1 here\u0026rsquo;s that information in form of a graph:\nIt turns out there are actually three different ticks in the engine \u0026ndash; one tick running before physics, one tick running together with physics, one tick after physics. Every actor ticks in one of these groups unless the game is paused; input is usually handled before physics. All these ticks receive an argument DeltaTime, passing the passed world time in seconds since the last tick.\nThis world time is not real time! The engine can run in slow-motion or fast-forward by scaling this DeltaTime down or up, try the console command slomo 2 for faster tactical gameplay.\nPause is not slomo 0! In pause, most actors don\u0026rsquo;t tick at all. slomo has a minimum scale of x0.1.\nPhysics Not only the input, almost all things tick before physics by default:2\ndefaultproperties { // For safety, make everything before the async work. Move actors to // the during group one at a time to find bugs. TickGroup=TG_PreAsyncWork } It makes sense to run most gameplay ticks before physics to give physics an opportunity to immediately react to changes from gameplay.\nAt the same time, some things must run after physics, for example camera positioning. If the camera positioned itself before physics and physics then moved the object the camera was focusing on, the camera would lag behind by one entire frame (up to 30ms at 30 FPS).\nAnd then, there\u0026rsquo;s code that can run safely in parallel with physics without any issues. This is a performance optimization: On any machine with more than one CPU core, running more things in parallel with physics is \u0026ldquo;free\u0026rdquo; as long as physics are more expensive.\nThis is helped by the fact that the actual physics update runs no UnrealScript code at all, so the engine doesn\u0026rsquo;t immediately explode when it runs UnrealScript code together with physics. On the other hand, UnrealScript code running TG_DuringAsyncWork should not access any variables touched by physics, which would cause unpredictable behavior in face of incomplete results.\nVery few things actually use TG_DuringAsyncWork, mostly because it\u0026rsquo;d be surprising and premature optimization is the root of all evil.\nAll code that doesn\u0026rsquo;t run in parallel with physics blocks the entire game loop. For example, if the AI decides to move a unit (somewhere in the Pre-Async Tick), it needs to select an appropriate tile \u0026ndash; from a list of potentially hundreds of tiles! This scoring of tiles takes quite a bit of time and for the entire duration of that loop, nothing in the game can make progress. The longer this takes, the more noticeable the arising short lag spike.\nGames are real-time programs. Depending on the desired frame rate, there is a soft deadline of 33ms (30 FPS), 17ms (60 FPS), or 7ms (144 FPS). When the total computations for a single frame take longer than that, we miss the deadline. This doesn\u0026rsquo;t cause any problems with the hardware, but it degrades the quality of the service.\nCooperative Multitasking Splitting Work The UnrealScript implementation of tile scoring manages about 30 tiles per millisecond on my Intel Core i5-3470 @ 3.20GHz. However, several hundred target tiles aren\u0026rsquo;t unusual: Even the earliest units in the game (with a comparatively low mobility) have about 60 target tiles in a wide single-level Gatecrasher map. Terror missions with high-mobility units, several building floors and complex cover situations can make this a whole lot more expensive.\nOn the other hand, tile scoring isn\u0026rsquo;t urgent. It\u0026rsquo;s totally fine to only score a few tiles in one frame, a few in the next frame, and so on until it\u0026rsquo;s done:\nfunction StartScoringTiles() { TilesToScore = //... retrieve tiles list from native cache IsScoringTiles = true; } event Tick(float DeltaTime) { super.Tick(DeltaTime); if (IsScoringTiles) { // Score 50 tiles... } if (TilesToScore.Length == 0) { IsScoringTiles = false; } } There is no parallelism going on. Every frame, we spend most of our time on \u0026ldquo;the usual\u0026rdquo;, and a little bit of time on tile scoring. At the same time, we clearly kick off the tile scoring task and it\u0026rsquo;s done at some later point without blocking on its completion.\nThis illustrates the difference between concurrency and parallelism. Parallelism happens when two tasks make progress at the same time, concurrency allows tasks to start and complete in overlapping time periods even though only one task can make progress at a time.\nThis can only work because the AI system is built with the ability to wait for results in the first place, and wouldn\u0026rsquo;t work if it immediately demanded results. We call this cooperative multi-tasking because our code needs to explicitly stop doing its work for other code to resume.\nTimers This works great, but has the small problem that our Tick function becomes a bit overcrowded. We have to remember to call super.Tick(DeltaTime), and for every task we could ever run, our Tick function becomes lengthier. We can fix this by using native timers:\nfunction StartScoringTiles() { TilesToScore = //... retrieve tiles list from native cache IsScoringTiles = true; SetTimer(0.001f, false, nameof(ScoreTiles)); // Set non-repeating timer in 1ms } function ScoreTiles() { // Score 50 tiles... if (TilesToScore.Length \u0026gt; 0) { SetTimer(0.001f, false, nameof(ScoreTiles)); // Queue another 50 tiles } else { IsScoringTiles = false; } } This keeps our Tick function tidy and our deadlines happy.\nAsync loading This is basically what the game does when asynchronously loading objects in the background. Every frame, the Unreal Engine 3 dedicates at most 5 milliseconds to background loading.\nThis makes our loading performance (as well as our earlier AI calculations) dependent on the frame rate. We can calculate the loading efficiency (percentage of time spent on loading; performing a blocking load would be 100%):\nRegular frame rate Async-loading frame rate Loading Efficiency 30 FPS 26.1 FPS 13% 60 FPS 46.2 FPS 23% 144 FPS 83.7 FPS 42% → ∞ FPS 200 FPS 100% XCOM 2 (vanilla) uses async loading for the entire tactical map while viewing the dropship. On a machine that manages about 30 FPS in the dropship (no matter whether CPU or GPU performance is to blame), the tactical map takes more than seven times as long to load than would be necessary.\nWar of the Chosen shows a black screen while loading the map, which brings us close to the optimal performance and speeds up the tactical transition by a factor of 7 on low-end machines!\nState code In the example we\u0026rsquo;ve looked at before, we had a task that is computationally expensive but easy to split up. It turns out that there is also the opposite kind of task: A task that is complex enough to not be trivially breakable, but spends a lot of time just waiting.\nOne such example is the code that sets up the tactical session. We have to wait for the UI to be ready, then do a bit of setup, then wait for the dropship to be ready, wait for the plot to load in, wait for the map to generate, wait for the map pieces to load in, wait for the mission intro to finish, and then we can start the actual battle:3\nstate CreateTacticalGame { Begin: while (UIBusy()) { Sleep(0.0f); } StartLoadingDropship(); while (DropshipLoading()) { Sleep(0.0f); } ShowDropship(); StartLoadingMap(); while (MapLoading()) { Sleep(0.0f); } HideDropship(); BuildMapData(); SpawnUnits(); while (MissionIntroPlaying()) { Sleep(0.0f); } GotoState('TurnPhase_Begin'); } State code is allowed in Actors and automatically executed when the actor ticks. Sleep is a latent function: When we call it, the UnrealScript virtual machine saves that the Actor was in that particular state and called that function, returns from state code execution, and checks again next frame.\nA Sleep(0.0f) immediately resumes execution the next frame \u0026ndash; upon which our loops just check the condition again and go to sleep if not met. Implemented with functions and timers, this would be spread across over 10 functions.\nLatent functions are actually return statements in disguise: They return upon calling them and continue execution at some point in the future.\nState code is also often used with Actions and the animation system \u0026ndash; Pawns have a latent FinishAnim function that plays an animation and resumes execution when the animation has played. Here is a simplified copy of the Grapple action:\nstate Executing { Begin: UnitPawn.StartAnim('NO_GrappleFire'); while( ProjectileHit == false ) { Sleep(0.0f); } // Have an emphasis on seeing the grapple tight Sleep(0.1f); UnitPawn.StartAnim('NO_GrappleStart'); while( !ReachedTarget() ) { if( !UnitPawn.PlayingAnim() ) { break; } Sleep(0.0f); } // send messages to do the window break visualization SendWindowBreakNotifies(); FinishAnim(UnitPawn.PlayAnim('NO_GrappleStop')); CompleteAction(); } The XComIdleAnimationStateMachine, also making use of state code, has a function TurnTowardsPosition4 that only resumes execution in that state when the animation system has driven the pawn to turn towards a position. This can take several seconds in world time.\nRemember how I said latent functions are return statements in disguise? There\u0026rsquo;s not really a way to save something in locals for us to use after we call return, so state code can\u0026rsquo;t have local variables. Code between latent function calls can be factored out into regular functions with locals, but state saved across latent function calls must be saved in class variables.\nOther programming languages like C++, C#, Python, Rust and many more call this programming paradigm stackless coroutines. Relevant keywords are async, await, generator, yield.\nMost programming languages automatically derive the state saved across yield points (which latent function calls are) and save them in an anonymous object. UnrealScript is rather simplistic, that\u0026rsquo;s why locals in state code aren\u0026rsquo;t allowed.\nPreemptive Multitasking Sometimes cooperative multitasking isn\u0026rsquo;t a viable solution \u0026ndash; either because we can\u0026rsquo;t rely on other code cooperating with important code, or because the task itself doesn\u0026rsquo;t have predictable yield points.\nAudio The Audio mentioned in the game loop diagram is Unreal Engine 3\u0026rsquo;s audio (SoundCues) and notably does not run in parallel with anything. If a frame takes a bit too long, the audio backend runs out of audio data to\u0026hellip; convert into sound5 and the audio starts stuttering.\nThis is because the audio system does a little bit of work every frame (to fill the audio buffers), but it can\u0026rsquo;t defend against other tasks taking too long when it\u0026rsquo;s part of the game loop.\nXCOM 2 solves this problem by using a custom audio middleware called Wwise, which runs on an entirely different operating system thread and only exchanges simple events and messages with the game loop. This allows it to make sound without waiting for audio data by running in parallel with the game code.\nThe operating system has a scheduler that regularly switches between the threads that a process has spawned (or runs several of them in parallel) and ensures that all threads \u0026ndash; including the main thread and the audio thread \u0026ndash; can do their work. Pausing a thread this way, without cooperation, is called preemption; switching to another thread requires a context switch.\nThe operating system is pretty powerful. It will save the call stack and CPU registers so that the thread can resume the next time from the exact point it was preempted. The same mechanism also allows multiple processes to run on one machine \u0026ndash; every process has at least one thread.\nPhysics also makes use of that functionality, with a small difference: Audio uses a thread that always runs for the entire runtime of the game, while the physics task is joined so that the main thread continues with Post-Async Tick only after physics are done.\nEven though mod developers have no convenient way to author Wwise audio, music pieces should not be implemented with SoundCues because the stuttering is just awful.\nIf you\u0026rsquo;re interested in using Wwise for music, nintendoeats adapted my Music Modding System to Wwise audio and wrote a guide for those wanting to make use of Wwise for music packs.\nGame states One of the most expensive kinds of calculations is building a new tactical game state, especially when it drags a long chain of events after it (consider a long movement triggering several reaction shots and environmental damage). We\u0026rsquo;ve explored in a previous blog post how all game states are immediately built upon confirming the action. In the vanilla game, this most often causes a short but noticeable freeze upon confirming an ability, and a reduced frame rate and stuttering if AI reacts and builds game states in the frames after.\nWe can\u0026rsquo;t really apply our previous solutions because cooperative multitasking requires our tasks to be able to easily yield control to the game loop at certain intervals. We just can\u0026rsquo;t do this with game states \u0026ndash; context and state submission are a recursive and unpredictable algorithm. Often we trigger certain events and every listener might decide to do whatever.\nWar of the Chosen changes game state submission so that when we submit a context, we perform building the game state (and all its response states) on a separate OS thread. We don\u0026rsquo;t wait for it to be done, but once it\u0026rsquo;s done, we can use the results. The History is enhanced with some thread-local data6 to allow the game state thread to access the currently built states, while the main thread still looks at the tip of the latest fully built event chain.\nI don\u0026rsquo;t believe Firaxis enhanced the UnrealScript virtual machine to the point where two OS threads can run UnrealScript in parallel \u0026ndash; many data structures and globals are not thread-safe, and employing locks would be a huge performance degradation.\nMy best guess is that even though we have several OS threads, only one of them is running UnrealScript at a time while the other is just parked by the OS. The engine could then switch off the game state thread at certain safe points like the end of statements. That way we get the state-saving logic for free from the OS without really implementing any cooperation.\nThe game\u0026rsquo;s UI won\u0026rsquo;t allow you to perform any other actions while a game state is being built, but it fixes the visual freeze. It also subverts one of our fundamental assumptions: At any point in tactical, a game state might be in flight on another thread.\nIf you write code that allows the user to initiate context or game state submissions in tactical, you must check that `XCOMGAME.GameRuleset.IsDoingLatentSubmission() returns false. Otherwise two threads will be building game states in parallel \u0026ndash; a race condition.\nClosing Words Turns out there\u0026rsquo;s quite a bit of nuance to concurrency and parallelism in UnrealScript and XCOM 2. Even on the single main thread that runs the game loop, we can find ways to run tasks concurrently. I personally found it very interesting how early UnrealScript (in UE 2!) had coroutines, a functionality many other mainstream programming languages are only gaining today.\nOf course, much of the Unreal Engine 3 remains single-threaded and cannot be parallelized in any way. Future, more efficient engines make more use of the several CPU cores every modern machine has, especially with single-core CPU performance plateauing.\nSee UDK | Actor Ticking\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee Actor/defaultproperties\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee X2TacticalGameRuleset.state'CreateTacticalGame'\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee XComIdleAnimationStateMachine:TurnTowardsPosition\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThere does not appear to be a word corresponding to \u0026ldquo;visualize\u0026rdquo; for audio.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee XComGameStateHistory:LatentUpdateThreadID\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-11-10","permalink":"https://robojumper.github.io/too-real/multitasking/","tags":["unrealscript","xcom2"],"title":"Multitasking"},{"content":"Most XCOM 2 mod developers will in some form be familiar with the History and Templates. And yet, I think it is useful to take a step back and understand the bigger picture around Firaxis\u0026rsquo; implementation of the Model-View-Controller pattern.\nWe will roughly outline the motivation behind and the benefits of such an architecture and how the History/GameStateObjects, Templates, Contexts, Actions, and Pawns arise from MVC\u0026rsquo;s requirements. This will hopefully lead to a more intuitive understanding of their roles.\nFinally, we will look at some particular quirks in the XCOM 2 implementation that are useful to know about in order to write robust code.\nMotivation An integral part of a video game is showing things on the screen. The Unreal Engine 3 has some incredible ways to easily get something to draw on screen: Beyond providing a renderer, there\u0026rsquo;s a functional world/camera system, Actors we can attach mesh components to, extending to Pawns providing an animation pipeline and physics.\nAs soon as we use the engine to draw a soldier on the screen, we already get a significant part of the gameplay-relevant functionality for free. We can use the animation pipeline to implement movement. Multiplayer is already handled by the engine. We give the player a direct presentation and intuitive understanding of the state of the board!\nEverything is going great! The prototype advances rapidly, plenty of bugs crop up, plenty of bugs are fixed. And yet, some particular bugs seem to happen more frequently. There are reports of the grappling hook causing its users to fall through the floor under rare circumstances. Multiplayer gameplay performs some actions twice, or not at all. We miss 100% shots.\nWorse, we don\u0026rsquo;t really know how to reproduce and fix these problems \u0026ndash; perhaps not even what part of the engine or content is responsible! Do our maps have holes in them so that soldiers fall through? Is the physics engine buggy, or are the animations breaking some rules? Is network replication configured correctly? Do our projectiles live long enough?\nReplication is the Unreal Engine 3 solution to multiplayer and networking. It features a client-server architecture, remote procedure calls, synchronization of variables, lossy data compression, reliable/unreliable data and much more.\nNobody in the XCOM 2 community knows how it works and the one remnant (UI functions being marked simulated) continues to be cargo-culted. This is because replication is entirely irrelevant to XCOM 2. I assume it was quite tricky to get right in XCOM EU/EW.\nWhat these have in common is that systems ostensibly designed for the visual presentation are on the same rank as the actual gameplay:\nWe have a hard time enforcing invariants and separation of concerns. Nothing could possibly tell the game engine that physics should never move a unit to the adjacent tile when it is idling, or that a unit must successfully land after grappling. Even saving and re-loading a save can\u0026rsquo;t fix it: Our unit has permanently fallen off the map!\nIt would be great if there was an authoritative representation of the tactical board, manipulated only by our own gameplay code. The visual presentation would then only read from that representation.\nThis problem is often encountered in frontend applications and user interface. Of course, buttons can\u0026rsquo;t fall out of the window, but putting our windowing library and GUI toolkit in charge of our business logic can have similarly bad side effects \u0026ndash; outdated display, greyed-out buttons that should be enabled, impossible input, and a lot of shared responsibilities.\nIt\u0026rsquo;s not surprising that the solution employed in XCOM 2 originated from user interface development, sometime in the 70\u0026rsquo;s.\nModel-View-Controller Model-View-Controller (MVC) aims to solve this issue by:\nDefining a clear boundary between the current state (Model) and the visual presentation (View) Requiring a clear set of rules through which the model is manipulated (Controller) Ensuring that the View has read-only access to the Model and all modifications to the Model are made through the Controller Don\u0026rsquo;t attempt to clearly and unambiguously define where exactly the boundary between Model and Controller lies (or what a Controller actually is). Everyone and their grandmother has their own opinion on that topic. For the purpose of this post, we\u0026rsquo;ll just roll with one particular interpretation \u0026ndash; mine.\nFlow of information We\u0026rsquo;ll need XCOM 2 terminology here quite a bit, so here\u0026rsquo;s a very condensed explanation of the core tactical gameplay systems:\nThe History stores the current state of the battle. The GameRules manage the player turns and build a list of AvailableActions for all Players and the currently active Player gets to submit one of these actions in form of a Context. The GameRules evaluate this Context and submit the resulting changes to the History, allowing reaction abilities to trigger, giving temporary turns to scampering or reacting units.\nThe Visualization independently watches for changes to the History and updates world and pawns.\nLet\u0026rsquo;s visualize this in a diagram where arrows denote flow of information:\nOne thing in particular is worth pointing out right now: No data flows from the View to anywhere else! Evaluation of ability activation does not rely on visualization having occurred. Two AI players, who have inherent access to available actions, could play the game entirely without visualization.\nThis is a pretty compelling insight into XCOM 2\u0026rsquo;s MVC: Can the AI play without it? Then it\u0026rsquo;s View.\nLet\u0026rsquo;s look at some of these parts in more detail!\nHistory Details Some of this info is also available on the Game States page of the /r/xcom2mods wiki. That particular page contains some useful code samples for directly interacting with the History as it is implemented in XCOM 2.\nObjects We need all sorts of information in our model. Information about units, items, their abilities, applied effects, the state of the mission script, objectives. It makes sense to use UnrealScript\u0026rsquo;s inheritance/polymorphism system for this: We create a class XComGameState_BaseObject extends Object;. Everything we store as part of the model must be a subclass of XComGameState_BaseObject. This rules out quite a bit of nonsensical interactions: We can\u0026rsquo;t store Actors in our model (which would be terrible since they\u0026rsquo;re tied to the world), similarly we can\u0026rsquo;t store StaticMeshes. Nice and controlled.\nIn the interest of keeping things succinct, I will abbreviate the XComGameState_ prefix with XCGS_. Instances of XCGS_ classes are called \u0026ldquo;state objects\u0026rdquo;.\nHowever, our classes can have arbitrary properties (class variables). Which kinds of these can we save and load? After all, even though we\u0026rsquo;re limited to adding state objects to the model, we could simply have a var StaticMesh EvilProperty;. What about var XCGS_BaseObject RefToSelf;? Or other weird data structures that interface closely with the UnrealScript virtual machine?\nThe process of saving is called serialization because it transforms a complex structure of objects into a serial byte stream. The opposite procedure, deserialization, follows.\nFiraxis made the pragmatic decision to simply not support Object properties when de-/serializing. This avoids cyclicity issues entirely.\nReferring to other state objects objects is a legitimate requirement on the other hand \u0026ndash; without it, we couldn\u0026rsquo;t realize that units actually own items and abilities. The solution is quite simple: We give every state object a numeric ObjectID. State objects keep this ID throughout the entire campaign and IDs will not be re-used. The model provides a way to get the state object for a given ID, so we only need to store the ID when referring to other objects. Firaxis wraps this integer in a single-member struct called StateObjectReference to neuter all the arithmetic functions useful for integers but entirely pointless for IDs.\nWhen implementing your own XCOM 2 state objects, bear in mind that only primitive types as well as structs and arrays are fully supported (except for their Object parts, should they have any). Objects properties are sometimes used for caching purposes precisely because they don\u0026rsquo;t persist in the save file.\nDelegates (references to functions owned by objects) are special and actually participate in serialization. Avoid var delegate in state objects unless you know what you are doing and you can ensure that the owning object is a state object or has a persistent name (i.e. the function is a static method).\nFrames This simple model has one problem: Our visualization, generally responsible for visualizing changes, can only view the state at one point in time. Worse, if gameplay advances, visualization may miss certain states and instead look at a future state. It is genuinely useful to be able to look at past and future states!\nIf a unit was on overwatch in the past state and is now no longer on overwatch, we can show an \u0026ldquo;Overwatch removed\u0026rdquo; flyover.\nIf a movement will result in three other units performing overwatch shots, we can prepare a super cinematic camera movement.\nIt makes sense to store our model as an append-only list of state changes. Let\u0026rsquo;s call it the History. In order to modify the History, we create a new container (XComGameState) and clone the objects before adding them to this container and modifying them. When it\u0026rsquo;s done, we submit it to the history.\nWe call the XComGameState \u0026ldquo;game state\u0026rdquo;. Note that game states and state objects (XComGameState_BaseObject, XComGameState_Unit) are different. To make things more confusing, \u0026ldquo;state\u0026rdquo; can refer to game states as well as state objects, for example \u0026ldquo;unit states\u0026rdquo;.\nTo disambiguate, game states are sometimes referred to as \u0026ldquo;history frames\u0026rdquo;.\nAs an optimization, we only need to clone the objects we are interested in modifying:\nIn this example, Unit 2 shot Unit 1 with Item 3 using a free Ability 5. Unit 2 did not change at all, but is still part of the updated state because it generally makes sense to have the shooter in the game state. Unit 1 lost health and the Overwatch status, Item 3 used ammo. Unit 4 did not participate in the action at all.\nEven though the object names change, the IDs stay the same. The ObjectID can be used to uniquely identify and track all state objects!\nHold on to and pass around StateObjectReferences, not XCGS_ objects. The more state objects you pass around, the higher the risk of using outdated information.\nOn the other hand, simply requesting state objects from the history may result in you looking into the future. You can query game states for state objects and ask the History for the state objects at arbitrary history indices. This is especially important for visualization, which may end up spoiling results if it doesn\u0026rsquo;t look at state objects from the exact history index as the visualized game state.\nThis allows us to answer all kinds of queries and enables as a bonus a History replay feature: We can load a completed tactical save in replay mode and step through the history, never submitting anything on our own.\nIn Context Of Now that we have a rough understanding of the History, it\u0026rsquo;s time to consider the role of the Contexts (classes with an XComGameStateContext_ prefix, here abbreviated as XCGSContext_, sometimes also XCGSC_). In our original diagram, players and networking submit contexts in order to initiate changes in the history. Why go through this extra hoop?\nIt turns out that players can\u0026rsquo;t actually be trusted to play by the rules. Permitting the AI as well as human players to build their own game states is dangerous: Both AI and UI may operate on outdated information and essentially \u0026ldquo;cheat\u0026rdquo;. It is far safer to present players with a list of available actions and let them choose one action. The game rules can validate this action easily \u0026ndash; after all, the game rules handed out the action in the first place.1 The context can then build the game state and the game rules add it to the History.\nThe XCGSContext_Ability contains little information, but enough to deterministically build the game state. In our example, it would contain something akin to \u0026ldquo;Unit 2 uses Ability 5 with Item 3 against Unit 1\u0026rdquo;. Contexts are stored together with their corresponding game state. This has some great advantages:\nMultiplayer can be realized by sending the contexts only and letting both sides evaluate the context and build the game state independently Daily mission leaderboards can be validated by validating the contexts and checking if they create the same game states The tactical tutorial (a special history replay) can be realized by simply checking if the to-be-submitted context matches the stored context (rejecting it otherwise) and just not submitting anything, instead advancing the replay All tactical user input must submit a context to achieve changes. It\u0026rsquo;s perfectly fine to submit game states directly in response, for example from event listeners, as long as the entire event chain can deterministically be triggered from the original context.\nIn other words, game states contain the answer to \u0026ldquo;what changed?\u0026rdquo;, contexts the answer to \u0026ldquo;why did it change?\u0026rdquo;\nInputs and Outputs Unfortunately, one piece is still missing: We don\u0026rsquo;t know about some intermediate results that lead to the changes. In our example, did the shot graze and deal 2 damage, or did it miss but deal 2 damage due to the stock weapon upgrade?\nFortunately, since we store the context in the History, we can simply store that information in the context itself. The XCGSContext_Ability thus has variables part of the input context (who used what against whom?) and part of the output context (what\u0026rsquo;s the hit result and damage values? which effects applied successfully?)2\nInterruptions Contexts play another important role because they can produce more than one game state (the context will be cloned for every game state). For example, every regular ability activation first submits a \u0026ldquo;fake\u0026rdquo; activation (eInterruptionStatus_Interrupt) that triggers relevant events, but doesn\u0026rsquo;t actually apply any effects. This gives reaction fire abilities a chance to react before the ability performs its effects (consider Overwatch + Covering Fire).\nIf nothing happened in response, this fake game state is removed from the history and the ability is properly activated (eInterruptionStatus_None). Otherwise, the original game state and all response game states are kept, a copy of the original context is re-validated (the unit may have died from reaction fire), and this copy is properly submitted (eInterruptionStatus_Resume).3\nFurther, movement abilities trigger an interruption game state for every single step. Only the steps actually causing a reaction and the final step are kept. If no response actions are performed along the path, the movement is a single jump from source to destination.\nIf you have an event listener for successful ability activations, you may want to filter interruption steps with if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) return ELR_NoInterrupt;, lest your code runs twice for every ability activation.\nWith all this in mind, it\u0026rsquo;s perhaps best to review the architecture diagram and see if it makes more sense.\nTemplated Templates sort of transcend the entire system. They contain view data, game rules input, and instructions for game rules. Dissecting the X2AbilityTemplate, we have:\nView Ability icons Targeting methods (allowing the user to select an action) BuildVisualizationFn (prepares the visualization for activated ability) Game rules input Conditions Costs Target styles (building the list of actions) Game rules instructions Effects Costs BuildNewGameStateFn (builds the game state for activated ability) This is, of course, not a violation of MVC. We factored all of these aspects into the original architecture diagram. No data flows from View to anywhere else.\nArchived Our approach to the History has the problem of unlimited growth. With every mission, our save file contains more and more objects, and more and more versions of the same object. This would spiral out of control quickly. Firaxis employs a number of mitigations.\nTacticalTransient objects are never retained after the end of a tactical mission. This includes ability states, effect states, and players. You can make objects TacticalTransient by setting the class variable bTacticalTransient in defaultproperties:\ndefaultproperties { bTacticalTransient=true } Items and Units are not TacticalTransient, so even dead enemies and their items from tactical missions are retained. Additionally, we still store more and more history frames and contexts even though we don\u0026rsquo;t need to look back into what happened on turn 3 of Gatecrasher.\nStartStates are game states that act as a barrier. When we go from strategy to tactical, we create a start state and copy everything relevant into that start state. This includes units in the squad and excludes units not in the squad. When we iterate over all units in the History from now on, we only get the units actually on the battlefield.\nStart states are the only game states that are allowed to be modified after being submitted as long as they\u0026rsquo;re the latest game state in the history. They are usually combined with a History lock that prevents other game states from being submitted.\nThe strategy-\u0026gt;tactical transition is a relatively complex series of loading maps, instantiating state objects for map actors, spawning units, and setting up the mission script, all while the start state is on top of the History. At some point the History is unlocked and everything proceeds as normal.\nAt the same time, submitting a start state causes all previous game states to be squashed into a single game state with an \u0026ldquo;archive\u0026rdquo; context. At the end of the battle, this archive state is retrieved, its objects are copied into the new strategy start state, and the objects are updated with their tactical versions in case they participated in the tactical session.\nThe tactical History is missing objects. If you use OnLoadedSavedGame to make modifications with the installation of your mod, your changes may find some strategy objects missing. Prefer a combination of OnLoadedSavedGameToStrategy and OnPostMission.\nIf you write code that relies on certain objects being brought along in a strategy-\u0026gt;tactical transition, you can add them in OnPreMission.\nIdeally this would mean that at some point, all enemy units and their weapons would be left behind. Unfortunately, there are multi-part missions like the Shen\u0026rsquo;s Last Gift tower mission. This tactical-\u0026gt;tactical transfer would mean strategy objects would be left behind, so we can\u0026rsquo;t leave objects behind and the archive state continues to accumulate some garbage.\nThere is an attempt to fix it in the Highlander. Everybody is scared to approve it because it may delete important units from mods that re-use base-game templates.\nViolations There are a number of ways you can violate MVC:\nDirectly submit game states from user input in tactical Modify state objects part of already submitted game states Submit contexts or game states from visualization Make changes dependent on the current state of the visualization Cause observable side effects from code building a game state Attempt to build a game state while there is a game state currently being built Sometimes it\u0026rsquo;s not obvious whether a game state is \u0026ldquo;in flight\u0026rdquo;. Event listeners registered with ELD_Immediate for events triggered in game state code can usually rely on NewGameState being in flight and mutable, but event listeners registered with ELD_OnStateSubmitted cannot. The Events/Deferral section of the /r/xcom2mods wiki elaborates on this point further.\nMoreover, a game state might sometimes be in flight due to multi-threading/latent submissions in WotC. This deserves a separate blog post, just don\u0026rsquo;t submit a context while `XCOMGAME.GameRuleset.IsDoingLatentSubmission() returns true for now.\nFor the rest of the blog post, we\u0026rsquo;ll look at some particular violations that happen in base-game code.\nUnconscious Units Units knocked out will have a knockback effect applied to them that may move them to a different tile. Physics rarely cooperate, so once the ragdoll settles, it submits a game state that corrects the unit\u0026rsquo;s position.4 This ensures the unit is where players would expect it to be, but can cause race conditions with AI code.\nI think this violation is not justified, especially in face of the practical issues it causes with AI.\nHit Rolls A perhaps surprising fact is that rolling for an ability hit happens entirely before a game state is built, despite the RNG seed definitely being part of the Model. Abilities actually support not submitting a game state upon failing to roll a hit. No abilities make use of this, but it seems like it was intended to work for the concealment system, where enemies would have a chance to notice player units.\nThis is a small violation as long as it only happens in reaction abilities / responses to events.\nMore seriously, some effects directly write to state objects in the history as part of determining ability hit results. Consider this simplified function from X2Effect_Parry:\nfunction bool ChangeHitResultForTarget(XCGS_Unit TargetUnit, out EAbilityHitResult NewHitResult) { if (TargetUnit.Parry \u0026gt; 0 \u0026amp;\u0026amp; TargetUnit.IsAbleToAct()) { NewHitResult = eHit_Parry; TargetUnit.Parry -= 1; return true; } return false; } This is about as serious in that it only happens in response abilities, but it does write directly to the History. Bad idea.\nThere are two kinds of random functions: The built-in Rand() function and the Firaxis `SYNC_RAND() macro. Use Rand() for visualization and `SYNC_RAND() for game state code \u0026ndash; the former does not affect the saved RNG seed, the latter does.\nAchievements and Mission Completion Steam/platform achievements are triggered when the game state is built. This essentially spoils results because the achievement pops up as soon as the player hits the \u0026ldquo;confirm\u0026rdquo; button. This could easily be fixed by making achievement unlocks part of the visualization.\nEvery context has a PostBuildVisualizationFn delegate array that can be added to from game state code in order to add additional visualization even if you don\u0026rsquo;t control the variables in the context.\nSimilarly, upon confirming the action that will complete the mission, all UI is hidden.\nThese are not MVC violations because no data flows from view, but more visualization bugs.\nMap At a glance, the map seems like a giant MVC violation. Actors are responsible for building the tile grid, pathing and visibility. Further, even though a lot of map actors are destructible, almost none of them have corresponding state objects.\nThis is handled by native code, but upon further inspection, the world data seems to be able to speculatively apply environmental damage and update visibility and pathing internally without visualization having occurred.\nMoreover, even though destructible map actors generally have no state objects, saving and loading retains environment damage. This is because the events that lead to map destruction are part of the history and simply re-played upon loading a saved game.5\nIf we recall our AI insight (\u0026ldquo;does the AI need this?\u0026rdquo;), then it\u0026rsquo;s resoundingly clear that the map and its meshes are part of the state too. It\u0026rsquo;s iffy and okay to feel a bit uneasy about, but it works OK-ish.\nSometimes map actors like to self-destruct right after confirming an action, but this could easily be just a visualization bug, not an MVC violation.\nCursor targeting Pixel hunting is the XCOM player\u0026rsquo;s favorite obsession. Unsurprisingly, grenades and heavy weapons allow freely targeting the ability on the tactical map, so the game rules don\u0026rsquo;t actually provide a list of all available actions and leave it to the players, which mostly results in the AI hitting seemingly (and sometimes actually) impossible shots \u0026ndash; players create the target for cursor-targeted abilities on the fly and there\u0026rsquo;s no validation.\nOn top of that, some targeting methods actually use info from the unit pawn to build the heavy weapon path, particularly around visibility checking and ray tracing.6\nThere\u0026rsquo;s no good solution for the first problem. Even tile-snapping would result in a huge possible target list. The second problem is a plain old MVC violation that should have been addressed by using the unit state tile location and not the actor location.\nStrategy This article was focused on tactical. The strategy gameplay is a lot less principled about this, knows no concept of available actions and often submits ChangeContainers (a dummy context where the game-state is pre-built already) directly. Narrative moments randomly interfere and cause race conditions with UI screens that have pending game states (like customization). Strategy keeps the History for state management, but doesn\u0026rsquo;t concern itself with MVC at all.\nClosing Words I hope this article was insightful and helped you understand XCOM 2\u0026rsquo;s tactical architecture. Moreover, I hope you will keep the presented concepts in mind and use them to confidently write and review code that interacts with the History, Contexts, and tactical MVC.\nI would like to thank Xymanek for reviewing a draft of this blog post and providing valuable feedback.\nSee X2TacticalGameRuleset:GetGameRulesCache_Unit\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee XComGameStateContext_Ability:InputContext/OutputContext and corresponding definitions in X2TacticalGameRulesetDataStructures\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee X2GameRuleset:SubmitGameStateContext_Internal\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee XComUnitPawn:SyncCorpse\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee XComGameState_EnvironmentDamage\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee X2TargetingMethod_RocketLauncher:Update, particularly FiringUnit.Location\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-11-03","permalink":"https://robojumper.github.io/too-real/history/","tags":["unrealscript","xcom2"],"title":"History"},{"content":" Welcome to Too Unreal, a blog post series about some lesser-known aspects of the XCOM 2 engine and the Unreal Engine 3 that it is based on, particularly about UnrealScript.\nThis series is not going to be a modding tutorial, but is instead meant to provide some additional details and insights into how things work under the hood. At the same time, I\u0026rsquo;m not keeping it too dry \u0026ndash; this series will contain case studies, personal anecdotes, and advice that will be useful to keep in mind if you end up working on more sophisticated UnrealScript code.\nOther topics I plan on covering are data layout, out parameters and subtyping, function dispatch, multitasking. I\u0026rsquo;m also open to suggestions; this blog uses utterances for comments.\nIn this blog post, we\u0026rsquo;re going to explore how strings and names in UnrealScript work.\nTextbook definitions The official UnrealScript documentation ends up being quite terse:\nstring\nA string of characters.\nname\nThe name of an item in Unreal (such as the name of a function, state, class, etc). Names are stored as an index into the global name table. Names correspond to simple strings of up to 64 characters. Names are not like strings in that they are immutable once created.\nEpic Games Unreal Script Variables This intuitively matches what we expect from those data types:\nlocal name MyName, MyName2; local string MyString, MyString2; MyString = \u0026quot;Hi\u0026quot;; MyString2 = MyString; MyString $= \u0026quot;, ÜC!\u0026quot;; // mutate string `log(MyString); // ScriptLog: Hi, ÃœC! MyName = 'Adv'; MyName2 = MyName; MyName $= 'M1'; //❌ Error, Left type is incompatible with '$=' MyName = 'Other'; // re-assignment isn't mutation Let\u0026rsquo;s delve into a bit more detail about how these data types might be implemented under the hood.\nStrings UnrealScript hides a lot of the complexity here but the C++ side needs to allocate memory for every variable. For a 32-bit integer (int), this size is known at compile-time (4 bytes), but a string can have arbitrary length (and grow/shrink at runtime). As a result, the string stores its data as a separate allocation:\nWith this, the data needed to store the string has a fixed size: A pointer to the actual data and the string length. These strings are terminated with a NUL character, as is common in the C world.\nLet\u0026rsquo;s see what happens when we append the \u0026quot;, ÜC!\u0026quot; to the existing string:\nThe string re-allocates: It allocates a new, longer block of memory, copies the old data into it, appends the new string, and throws away (\u0026ldquo;frees\u0026rdquo;) the old data. That\u0026rsquo;s why we can freely mutate a string. But this means that creating a copy of the string requires a new allocation and duplicates the string data: If both strings pointed to the same data, changing one string would change the other too \u0026ndash; or worse, we would throw away data that the other string is still referring to!\nEncoding Woes Unfortunately, the string isn\u0026rsquo;t what we expected: Instead of printing as \u0026ldquo;Hi, ÜC!\u0026rdquo;, it output \u0026ldquo;Hi, ÃœC!\u0026rdquo;. This is a consequence of the Unreal Engine 3 only supporting the ASCII and UTF-16 encodings when the original source file was saved in the UTF-8 encoding.\nEncodings are the way we represent codepoints (\u0026ldquo;characters\u0026rdquo;) of the character set as bytes. The most common character set is Unicode, and UTF-16 is one possible encoding. UTF-16 uses two bytes per character; UTF-8 uses 1-4 bytes per character.\nASCII is a mostly alphanumeric subset of Unicode that only requires one byte per character, and all ASCII strings encode to the same bytes as the equivalent UTF-8 string.\nThe Unreal Engine recognizes UTF-16 files by a Byte-Order-Mark (BOM), two unprintable bytes at the beginning of a file that indicate an UTF-16 encoding. An UTF-8 file has no BOM, so the compiler (being part of the engine) believes that the file is ASCII only and interprets the two bytes needed to represent the \u0026ldquo;Ü\u0026rdquo; codepoint as two ASCII characters \u0026ldquo;Ã\u0026rdquo; and \u0026ldquo;œ\u0026rdquo;.\nRestrict yourself to ASCII-only code. Localize strings, and save localization files with an UTF-16 BOM encoding.\nSome software, particularly source code management tools like git, will interpret UTF-16 files as binary files and not text. It can be useful to store localization files in UTF-8 and convert to UTF-16 as part of the build process, as done by Long War of the Chosen in its custom build script.\nNames Even though the official documentation makes it seem like names are reserved for built-in things, we can use names for anything! Case in point, the XCOM 2 engine uses names for Templates and configuration array entries like loot, loadouts or encounters.\nNames have some unique properties not mentioned in the documentation:\nThe empty name, '', compares equal to the name 'None'. Name comparison is case-insensitive: 'MyName' == 'mYnAmE'. Let\u0026rsquo;s look a bit into how this global name table works.\nThe Name Table The documentation says that names are stored as an index into the name table. This means that instead of owning the string data, a name is basically just a fancy int. We have a number of requirements for the implementation:\nNames should reliably and efficiently be comparable: Two names should compare equal if and only if their indices are equal. This means that comparing two names is as efficient as comparing two ints. Names should be efficiently created: No matter how many thousand names we already have, creating a name from a string should always take the same, low amount of time. Names should efficiently be serialized: While storing names as integers is great when the game is running, we should save them as strings when we write them to a file so that we don\u0026rsquo;t have to rely on the numbers being the same when the game boots up the next time (spoiler: they wouldn\u0026rsquo;t be). There are two pieces needed to make this work: The first is a name array; an ever-growing array containing every single name created, without duplicates. Whenever we want to create a name not already present in the name table, we can simply generate a new index by looking at the array length; and we can look up the string behind a name by indexing into this array. This piece already solves (1.) and (3.)!\nWhen creating a name, we have to check if a that name already exists \u0026ndash; otherwise, we could end up with the same name twice, and the same name would have a different index. Unfortunately, we\u0026rsquo;d have to iterate over the whole name array to find a name comparing equal. The Unreal Engine 3 solves this by employing a hash set.\nThis hash set is a fixed-size array with a comparatively low number of entries (say 32768), and we use a hash function to find the correct entry (\u0026ldquo;container\u0026rdquo;, \u0026ldquo;bucket\u0026rdquo;) for a given string. When we create a name from a string, we find the correct bucket, and check if the name is already there. If so, we have an existing name and re-use the index. If not, we add the new name to the name array and insert it also into this bucket.\nThe pigeonhole principle states that \u0026ldquo;if n items are put into m containers, with n \u0026gt; m, then at least one container must contain more than one item\u0026rdquo;.\nApplied to our hash set, there will be collisions: Different names will have the same hash, otherwise we could never have more than 32768 names. This means that we store multiple names in the same bucket, and still have to check multiple existing names to see if any of them match (although I\u0026rsquo;m unsure about the exact implementation, we\u0026rsquo;re going to assume that the Unreal Engine 3 uses linked list chaining).\nHowever, instead of checking N existing names, we only check N / 32768 names. Much better!\nIn addition to the special name 'None', we\u0026rsquo;ll consider the three names from our code snippet: 'Adv', 'M1', and 'Other'. Let\u0026rsquo;s see what our data structures look like:\nIn our example, the names were inserted in the afore-mentioned order. 'None' has the hash 0, 'Adv' the hash 2, and 'M1' and 'Other' both share the hash 5. When we created the name Other, M1 was already in that bucket, M1 does not compare equal to Other, so we linked 'Other' before 'M1' and placed 'Other' into that bucket.\nNames are an Unreal Engine 3 implementation of string interning: For every string, we only store data once, and can then cheaply create and compare several instances of the string. Memory leaks This implementation never reclaims unused name data. Once we create a name, it will reside in the name table (and thus memory) until the game is closed! We can easily test this with the following code:\nlocal string BaseString; local name TempName; local int i; BaseString = \u0026quot;MySomewhatLongerBaseStringForHigherMemoryUsage\u0026quot;; `log(\u0026quot;Starting...\u0026quot;); for (i = 0; i \u0026lt; 35000000; ++i) { TempName = name(BaseString $ \u0026quot;_\u0026quot; $ i); if (i % 500000 == 0) { `log(i); // progress indicator and timer } } `log(\u0026quot;Done!\u0026quot;); Let\u0026rsquo;s estimate the memory usage:\n\u0026quot;MySomewhatLongerBaseStringForHigherMemoryUsage\u0026quot; is 46 characters long. We add an underscore and 8 digits, and the NUL character (total 112 bytes with our above knowledge of strings). We require 4 bytes for the index, 8 bytes (on a 64-bit system) for the Next pointer, and another 8 bytes for the pointer entry in the names array. We expect memory usage to rise by about 112B * 35e6 = 4.62GB.\nThe measurements were performed on an Intel Core i5-3470 @ 3.20GHz, launched through a console command in TQL (to minimize interference from the game).\nTime: 39.86s Memory usage increase: 0MB Wait, what? Our memory usage had no significant change!\nLet\u0026rsquo;s revisit what our assumption would practically mean: When we new an object, say new class'XComLWTuple', the engine assigns a unique name to that object. We start with XComLWTuple_0, then XComLWTuple_1 etc. Even though our XComLWTuples are garbage collected, we never re-use existing numbers: Our tuple object names are monotonically increasing.\nIf names worked that way, we would reliably end up polluting our name table; and even though UnrealScript has a garbage collector, we would end up leaking memory!\nThe Number Optimization Simply put, a _Number suffix is stripped before interning. Our names don\u0026rsquo;t actually consist of one number, but two numbers instead. The first number is an index into the name array, the second number is the numeric suffix.\nLet 'XComLWTuple' be our sixth name. Then the name 'XComLWTuple' would be represented as 6|0 (0 for no suffix). 'XComLWTuple_0' would be represented as 6|1, 'XComLWTuple_1' as 6|2, 'XComLWTuple_345' as 6|346.\nOur example code managed to trigger this optimization: Our names are 'MySomewhatLongerBaseStringForHigherMemoryUsage_0', 'MySomewhatLongerBaseStringForHigherMemoryUsage_1', and so on. This means that the game interns the MySomewhatLongerBaseStringForHigherMemoryUsage once and all our synthetic names re-use that index, just with a different number part. Testing two names for equality is thus a matter of comparing the two integers of the two names.\nLet\u0026rsquo;s Break It For Real With this knowledge, we can try to circumvent this optimization:\nlocal string BaseString; local name TempName; local int i; BaseString = \u0026quot;MySomewhatLongerBaseStringForHigherMemoryUsage\u0026quot;; `log(\u0026quot;Starting...\u0026quot;); for (i = 0; i \u0026lt; 35000000; ++i) { //TempName = name(BaseString $ \u0026quot;_\u0026quot; $ i); TempName = name(i $ \u0026quot;_\u0026quot; $ BaseString); if (i % 500000 == 0) { `log(i); // progress indicator and timer } } `log(\u0026quot;Done!\u0026quot;); Time: 848.09s Memory usage increase: 3.11GB1 With this snippet, we leaked more than 3 Gigabytes of memory. This memory is permanently leaked and will not be reclaimed until we close the game.\nThere is another problem: With every name we synthesize, our hash set becomes less efficient. We never resize the 32768 entries large hash set, so we have more and more collisions, and we have to check longer and longer lists of interned names whenever we create another name. We can plot the elapsed duration over the number of names created:\nThe trained programmer recognizes this as an O(n^2) algorithm; An algorithm whose runtime is quadratic to some input size. The more names we add, the longer it takes to add another name. Algorithms like this are best avoided. Of course, 35 million names are a bit extreme, but not that extreme \u0026ndash; crash dumps indicate that a normally running game has about three million interned strings.\nBut this explains why we cannot concatenate names, and have to go through strings: A name type that conveniently allows concatenation and mutation would make it extremely easy to accidentally pollute the name table and inhibit performance until we close the game.\nNames are usually only created at game startup (including template creation code). Names should only contain alphanumeric characters and underscores.\nAvoid synthesizing arbitrary names after that, only convert from string -\u0026gt; name when necessary. _Number suffixes, however, are free.\nCapitalization We\u0026rsquo;ve explored the string -\u0026gt; name conversion in detail, but there\u0026rsquo;s one pitfall when going from name -\u0026gt; string: We can\u0026rsquo;t rely on any particular capitalization:\nlocal int MYcUstOMnAmE; `log('MyCustomName'); // ScriptLog: MYcUstOMnAmE The Unreal Engine uses names to represent the name of (among other things) local variables, so when the compiler encounters the 'MyCustomName' string, the name has already been interned as \u0026quot;MYcUstOMnAmE\u0026quot;. The name -\u0026gt; string conversion uses the first representation of the name it encountered, and that\u0026rsquo;s MYcUstOMnAmE.\nFlash UI You can actually cause breakage with this if even if you personally never interact with any code that relies on capitalization! Here\u0026rsquo;s a super cursed hack you can try in the Highlander:\n// in CHDLCInfoTopologicalOrderNode.uc var bool LeftPanel; And suddenly we broke our loadout menu:\nThis is because UIArmory_Loadout has this code:\nEquippedListContainer = Spawn(class'UIPanel', self); EquippedListContainer.bAnimateOnInit = false; EquippedListContainer.InitPanel('leftPanel'); This creates a UIPanel that links up with a panel of the name leftPanel on the Flash side \u0026ndash; except Flash is case-sensitive even though Firaxis\u0026rsquo; API takes names! The compiler parses our LeftPanel first, and when it encounters the leftPanel, LeftPanel is the interned representation.\nNever rely on the name -\u0026gt; string conversion to make any sense at all. Never display names to the user, only use them for debugging purposes.\nIf you interact with existing Flash UI directly, ensure you don\u0026rsquo;t have name conflicts with differing capitalization. In your own mods, you can\u0026rsquo;t break base game UI because you compile after base-game packages, but especially when working on the Highlander or when developing sophisticated UI, this is a huge footgun.\nWarning, INI file contains an incorrect case for There is a particularly annoying compiler warning that sporadically appears for some config variables:\n//⚠️ Warning, INI file contains an incorrect case for (CoverType) should be (coverType) var config ECoverType coverType; This warning references an INI file even when we haven\u0026rsquo;t modified any config files at all! This warning should better be described with\nWarning, config variable coverType actually named CoverType\nbecause the compiler had, at some point (perhaps even in XComGame) seen the name CoverType, so this variable is actually called CoverType. In fact, the compiler seemingly records this mismatch because config files are actually case-sensitive, and the runtime is clever enough to not use an arbitrary string representation of the variable name when loading from config.\nTo \u0026ldquo;fix\u0026rdquo; it, either follow the opposite of the advice and call it CoverType, or choose an entirely different name.\nClosing Words That\u0026rsquo;s it for the first entry in the series! If there is anything you\u0026rsquo;d like to have clarified regarding this topic, feel free to reach out in the comments!\nSimilarly, I\u0026rsquo;m open to suggestions for topics to cover next.\nThis memory usage is lower than expected. This is because names representable in ASCII are stored as ASCII to save space. The same happens when saving strings to packages or save files.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-10-27","permalink":"https://robojumper.github.io/too-real/names-strings/","tags":["unrealscript"],"title":"Names and Strings"}]